<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shor's 9-Qubit Code — Interactive Guide</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
  onerror="console.warn('KaTeX failed to load — math will display as plain text')"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
  onerror="console.warn('KaTeX auto-render failed to load')"
  onload="try{renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]})}catch(e){console.warn('KaTeX render error:',e)}"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap');
  :root {
    --bg: #0a0e1a;
    --surface: #111827;
    --surface2: #1a2236;
    --border: #2a3550;
    --text: #e2e8f0;
    --text-dim: #8892a8;
    --accent: #6366f1;
    --accent-glow: rgba(99, 102, 241, 0.3);
    --cyan: #22d3ee;
    --cyan-glow: rgba(34, 211, 238, 0.25);
    --pink: #f472b6;
    --pink-glow: rgba(244, 114, 182, 0.25);
    --green: #34d399;
    --green-glow: rgba(52, 211, 153, 0.25);
    --orange: #fb923c;
    --yellow: #facc15;
    --red: #f87171;

    /* Module-specific variables */
    --purple: #a78bfa;
    --font-mono: 'Menlo', 'Consolas', 'Courier New', monospace;
    --font-sans: 'Inter', system-ui, -apple-system, sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { scroll-behavior: smooth; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Inter', sans-serif;
    line-height: 1.7;
    overflow-x: hidden;
  }

  /* ---- Navigation ---- */
  nav {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    background: rgba(15,17,23,0.85);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--border);
    padding: 0 2rem;
  }
  nav .nav-inner {
    max-width: 1100px; margin: 0 auto;
    display: flex; align-items: center; gap: 2rem;
    height: 56px; overflow-x: auto;
  }
  nav a {
    color: var(--text-dim); text-decoration: none; font-size: 0.85rem;
    white-space: nowrap; transition: color .2s;
  }
  nav a:hover, nav a.active { color: var(--accent); }
  nav .logo { color: var(--accent); font-weight: 700; font-size: 1rem; letter-spacing: -0.02em; }

  /* ---- Layout ---- */
  main { max-width: 900px; margin: 0 auto; padding: 80px 1.5rem 4rem; }

  section {
    margin-bottom: 4rem;
    scroll-margin-top: 70px;
  }

  h1 {
    font-size: 2.4rem; font-weight: 800; letter-spacing: -0.03em;
    background: linear-gradient(135deg, var(--accent), var(--purple));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    margin-bottom: 0.5rem;
  }
  h2 {
    font-size: 1.6rem; font-weight: 700; color: var(--text);
    margin-bottom: 1rem; letter-spacing: -0.02em;
    padding-top: 0.5rem;
    border-top: 2px solid var(--border);
  }
  h3 { font-size: 1.15rem; font-weight: 600; color: var(--accent); margin: 1.5rem 0 0.6rem; }

  p { margin-bottom: 1rem; color: var(--text-dim); }
  p strong { color: var(--text); }

  .subtitle { font-size: 1.1rem; color: var(--text-dim); margin-bottom: 2.5rem; }

  /* ---- Cards ---- */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    margin: 1.5rem 0;
  }
  .card.highlight {
    border-color: var(--accent);
    background: linear-gradient(135deg, var(--accent-glow), transparent);
  }

  /* ---- Interactive Panels ---- */
  .interactive-panel {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1.5rem;
    margin: 1.5rem 0;
  }
  .panel-title {
    font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.08em;
    color: var(--accent); margin-bottom: 1rem; font-weight: 600;
  }

  /* ---- Qubit displays ---- */
  .qubit-row {
    display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
    margin: 0.8rem 0;
  }
  .qubit-box {
    display: inline-flex; align-items: center; justify-content: center;
    min-width: 48px; height: 48px; padding: 0 8px;
    border-radius: 8px; font-family: var(--font-mono); font-size: 1rem;
    font-weight: 600; border: 2px solid var(--border);
    background: var(--surface); transition: all .3s ease;
  }
  .qubit-box.ket { color: var(--cyan); border-color: rgba(34,211,238,0.3); }
  .qubit-box.error { color: var(--red); border-color: var(--red); background: rgba(248,113,113,0.08); animation: shake 0.4s; }
  .qubit-box.corrected { color: var(--green); border-color: var(--green); background: rgba(74,222,128,0.08); }
  .qubit-box.syndrome { color: var(--orange); border-color: var(--orange); background: rgba(251,146,60,0.08); }

  @keyframes shake {
    0%,100% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    75% { transform: translateX(4px); }
  }
  @keyframes errorFlash {
    0% { box-shadow: 0 0 0px var(--red); }
    50% { box-shadow: 0 0 16px var(--red); }
    100% { box-shadow: 0 0 0px var(--red); }
  }
  @keyframes correctedGlow {
    0% { box-shadow: 0 0 0px var(--green); }
    50% { box-shadow: 0 0 16px var(--green); }
    100% { box-shadow: 0 0 0px var(--green); }
  }
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.12); }
    100% { transform: scale(1); }
  }
  .qubit-box.error { animation: shake 0.4s, errorFlash 0.6s; border-style: dashed; }
  .qubit-box.corrected { animation: correctedGlow 0.6s; border-width: 2.5px; }
  .qubit-box.syndrome { border-style: dotted; }
  .qubit-box.just-changed { animation: pulse 0.3s ease; }
  @keyframes syndromeReveal {
    0% { opacity: 0; transform: scale(0.8); }
    30% { opacity: 1; transform: scale(1.08); }
    50% { opacity: 0.4; }
    70% { opacity: 1; }
    100% { opacity: 1; transform: scale(1); }
  }
  .qubit-box.syndrome-reveal { animation: syndromeReveal 0.5s ease; }

  .qubit-box:hover { transform: scale(1.05); box-shadow: 0 0 8px var(--accent-glow); border-color: var(--accent); }
  .qubit-box.error:hover { box-shadow: 0 0 10px rgba(248,113,113,0.3); border-color: var(--red); }
  .qubit-box.corrected:hover { box-shadow: 0 0 10px rgba(74,222,128,0.3); border-color: var(--green); }
  .qubit-box.syndrome:hover { box-shadow: 0 0 10px rgba(251,146,60,0.3); border-color: var(--orange); }

  .qubit-label {
    font-size: 0.75rem; color: var(--text-dim); margin: 0 6px;
    font-family: var(--font-mono);
  }

  /* ---- Buttons ---- */
  .btn-row { display: flex; gap: 8px; flex-wrap: wrap; margin: 1rem 0; }

  button, .btn {
    display: inline-flex; align-items: center; gap: 6px;
    padding: 8px 16px; border-radius: 8px; border: 1px solid var(--border);
    background: var(--surface); color: var(--text); font-size: 0.85rem;
    font-family: var(--font-sans); cursor: pointer; transition: all .2s;
    font-weight: 500;
  }
  button:hover { border-color: var(--accent); background: var(--accent-glow); }
  button:active { transform: scale(0.96); transition: transform 0.08s ease; }
  .syndrome-toggle:active { transform: scale(0.92); }
  button.primary {
    background: var(--accent); border-color: var(--accent); color: #fff;
  }
  button.primary:hover { opacity: 0.85; }
  button.danger { border-color: var(--red); color: var(--red); }
  button.danger:hover { background: rgba(248,113,113,0.1); }

  /* ---- Gate chips ---- */
  .gate {
    display: inline-flex; align-items: center; justify-content: center;
    padding: 2px 10px; border-radius: 6px; font-family: var(--font-mono);
    font-size: 0.85rem; font-weight: 700;
  }
  .gate-x { background: rgba(248,113,113,0.15); color: var(--red); }
  .gate-z { background: rgba(167,139,250,0.15); color: var(--purple); }
  .gate-h { background: rgba(34,211,238,0.15); color: var(--cyan); }
  .gate-cnot { background: rgba(108,140,255,0.15); color: var(--accent); }

  /* ---- Step indicator ---- */
  .steps { display: flex; gap: 4px; margin: 1rem 0; }
  .step-dot {
    width: 10px; height: 10px; border-radius: 50%;
    background: var(--border); transition: background .3s;
  }
  .step-dot.active { background: var(--accent); }
  .step-dot.done { background: var(--green); }

  /* ---- Circuit diagrams ---- */
  .circuit-svg {
    width: 100%; margin: 1rem 0; border-radius: 8px;
    background: var(--surface); border: 1px solid var(--border);
  }

  /* ---- Tables ---- */
  table {
    width: 100%; border-collapse: collapse; margin: 1rem 0;
    font-size: 0.9rem;
  }
  th, td {
    padding: 10px 14px; text-align: left;
    border-bottom: 1px solid var(--border);
  }
  th { color: var(--text); font-weight: 600; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; }
  td { color: var(--text-dim); font-family: var(--font-mono); font-size: 0.85rem; }

  /* ---- Math ---- */
  .math {
    font-family: var(--font-mono); color: var(--cyan);
    background: rgba(34,211,238,0.06);
    padding: 2px 8px; border-radius: 4px; font-size: 0.9rem;
  }
  .math-block {
    display: block; text-align: center;
    color: var(--cyan);
    background: var(--surface);
    padding: 1rem; border-radius: 8px; margin: 1rem 0;
    font-size: 0.95rem; line-height: 2;
    border: 1px solid var(--border);
    overflow-x: auto; -webkit-overflow-scrolling: touch;
  }
  /* KaTeX theme overrides */
  .katex { color: var(--cyan) !important; font-size: 1.1em; }
  .math-block .katex { font-size: 1.2em; }
  .katex-display { margin: 0 !important; overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; }
  .step-description .katex { font-size: 1em; }

  /* ---- Arrows / connectors ---- */
  .arrow { color: var(--text-dim); font-size: 1.4rem; margin: 0 4px; }

  /* ---- Info callouts ---- */
  .callout {
    border-left: 3px solid var(--accent);
    background: var(--accent-glow);
    padding: 1rem 1.2rem; border-radius: 0 8px 8px 0;
    margin: 1.2rem 0; font-size: 0.9rem;
  }
  .callout.warn { border-color: var(--orange); background: rgba(251,146,60,0.08); }
  .callout.success { border-color: var(--green); background: rgba(74,222,128,0.08); }
  .callout p { margin-bottom: 0.3rem; }

  /* ---- Stepper ---- */
  .stepper-controls {
    display: flex; align-items: center; gap: 12px; margin: 1rem 0;
  }
  .btn-icon { display: none; }
  .step-counter { font-size: 0.85rem; color: var(--text-dim); font-family: var(--font-mono); }
  .step-description {
    padding: 1rem; background: var(--surface); border-radius: 8px;
    border: 1px solid var(--border); margin: 0.5rem 0;
    min-height: 60px; font-size: 0.9rem; line-height: 1.6;
    transition: opacity 0.25s ease;
  }
  .step-description.fading { opacity: 0; }

  /* State flow indicator */
  .state-flow {
    display: flex; align-items: center; gap: 2px; margin-bottom: 0.5rem;
    flex-wrap: wrap; font-size: 0.75rem;
  }
  .flow-stage {
    padding: 3px 10px; border-radius: 12px; white-space: nowrap;
    background: var(--surface); border: 1px solid var(--border); color: var(--text-dim);
    transition: all 0.3s ease;
  }
  .flow-stage.flow-active {
    background: var(--accent); border-color: var(--accent); color: #fff; font-weight: 600;
  }
  .flow-stage.flow-done {
    background: rgba(74,222,128,0.15); border-color: var(--green); color: var(--green);
  }
  .flow-arrow { color: var(--text-dim); font-size: 0.65rem; margin: 0 1px; }

  /* ---- Hadamard demo ---- */
  .hadamard-grid {
    display: grid; grid-template-columns: 1fr auto 1fr; gap: 1rem;
    align-items: center; margin: 1rem 0;
  }
  .hadamard-grid .transform-arrow {
    font-size: 2rem; color: var(--cyan);
  }

  /* ---- Section entry animation ---- */
  @keyframes fadeInUp {
    from { opacity: 0; transform: translateY(24px); }
    to { opacity: 1; transform: translateY(0); }
  }
  section.animate-in { opacity: 0; transform: translateY(24px); }
  section.animate-in.visible { opacity: 1; transform: translateY(0); animation: fadeInUp 0.6s ease forwards; }

  /* ---- Hadamard result animation ---- */
  #had-result-grid {
    opacity: 0; max-height: 0; overflow: hidden;
    transition: opacity 0.4s ease, max-height 0.4s ease;
  }
  #had-result-grid.visible { opacity: 1; max-height: 200px; }

  /* ---- Error selector hint ---- */
  @keyframes hintPulse {
    0%,100% { box-shadow: none; }
    50% { box-shadow: 0 0 12px rgba(248,113,113,0.4); }
  }
  .error-selector.active-hint { animation: hintPulse 1.5s ease-in-out 3; }

  /* ---- Clickable qubit ---- */
  .qubit-box.clickable { cursor: pointer; }
  .qubit-box.clickable:hover { border-style: dashed; border-color: var(--red); }

  /* ---- Self-test questions ---- */
  .self-test {
    background: var(--surface2); border: 1px solid rgba(250,204,21,0.3);
    border-left: 4px solid var(--yellow); border-radius: 0 8px 8px 0;
    padding: 1rem 1.2rem; margin: 2rem 0;
  }
  .self-test summary {
    cursor: pointer; color: var(--yellow); font-weight: 600;
    font-size: 0.9rem; list-style: none; display: flex; align-items: center; gap: 8px;
  }
  .self-test summary::before { content: '?'; display: inline-flex; align-items: center;
    justify-content: center; width: 22px; height: 22px; border-radius: 50%;
    background: rgba(250,204,21,0.15); font-size: 0.8rem; font-weight: 700; }
  .self-test[open] summary::before { content: '!'; background: rgba(74,222,128,0.15); color: var(--green); }
  .self-test .answer { margin-top: 0.8rem; color: var(--text-dim); font-size: 0.9rem; line-height: 1.6; }

  /* ---- Skip nav ---- */
  .skip-link {
    position: absolute; top: -40px; left: 0; background: var(--accent);
    color: #fff; padding: 8px 16px; z-index: 200; border-radius: 0 0 8px 0;
    text-decoration: none; font-size: 0.85rem;
  }
  .skip-link:focus { top: 0; }

  /* ---- Focus styles ---- */
  button:focus-visible, .tab-btn:focus-visible, a:focus-visible, details:focus-visible {
    outline: 2px solid var(--accent); outline-offset: 2px;
  }

  /* ---- Responsive ---- */
  @media (max-width: 600px) {
    h1 { font-size: 1.6rem; }
    h2 { font-size: 1.3rem; }
    main { padding: 70px 1rem 3rem; }
    .qubit-box { min-width: 44px; height: 44px; font-size: 0.85rem; }
    .qubit-box-sm { min-width: 36px; height: 36px; }
    nav { padding: 0 0.5rem; }
    nav .nav-inner {
      gap: 0.75rem;
      mask-image: linear-gradient(to right, transparent 0, black 8px, black calc(100% - 24px), transparent 100%);
      -webkit-mask-image: linear-gradient(to right, transparent 0, black 8px, black calc(100% - 24px), transparent 100%);
      padding-right: 16px;
    }
    nav a { font-size: 0.72rem; }
    .compare-cols { grid-template-columns: 1fr; }
    .circuit-svg { margin: 0.5rem -0.5rem; width: calc(100% + 1rem); }
    .hadamard-grid { grid-template-columns: 1fr auto 1fr; gap: 0.5rem; }
    .stepper-controls { flex-wrap: wrap; gap: 8px; }
    .btn-icon { display: inline; }
    .btn-text { display: none; }
    .flex-center { gap: 16px; }
    .syndrome-toggle { width: 48px; height: 48px; }
    .card, .interactive-panel { padding: 1rem; }
    .callout { padding: 0.8rem 1rem; }
    .self-test { padding: 0.8rem 1rem; }
    .katex { font-size: 0.95em !important; }
    .math-block .katex { font-size: 1em !important; }
    .math-block { padding: 0.75rem; font-size: 0.85rem; }
    table { font-size: 0.8rem; }
    th, td { padding: 8px 10px; }
  }

  /* ---- Utility classes ---- */
  .text-center { text-align: center; }
  .ml-auto { margin-left: auto; }
  .helper-text { font-size: 0.9rem; color: var(--text-dim); margin-bottom: 1rem; }
  .text-orange { color: var(--orange); }
  .text-cyan { color: var(--cyan); }
  .text-red { color: var(--red); }
  .text-purple { color: var(--purple); }
  .flex-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  .flex-row-tight { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
  .flex-center { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
  .flex-center-tight { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
  .hint-text { font-size: 0.85rem; color: var(--text-dim); }
  .mt-1 { margin-top: 1rem; }
  .mb-1 { margin-bottom: 1rem; }
  .mb-sm { margin-bottom: 0.8rem; }
  .my-sm { margin: 0.5rem 0; }
  .my-md { margin: 0.8rem 0; }
  .ml-sm { margin-left: 12px; }
  .ml-xs { margin-left: 8px; }
  .justify-center { justify-content: center; }
  .qubit-box-sm { min-width: 30px; height: 34px; font-size: 0.8rem; }
  .qubit-box-md { min-width: 70px; }
  .qubit-box-wide { min-width: 100px; height: 34px; font-size: 0.8rem; }
  .qubit-box-label { font-size: 0.8rem; }
  .btn-orange { border-color: var(--orange); color: var(--orange); }
  .btn-purple { border-color: var(--purple); color: var(--purple); }
  .min-h-50 { min-height: 50px; }
  .error-selector.disabled { opacity: 0.4; pointer-events: none; }
  .table-auto-center { width: auto; margin: 0.5rem auto; }
  .th-center { text-align: center; }
  .mt-sm { margin-top: 0.5rem; }

  /* Glossary tooltips */
  .glossary-term {
    border-bottom: 1px dashed var(--accent); cursor: help; position: relative;
  }
  .glossary-tip {
    display: none; position: absolute; bottom: calc(100% + 8px); left: 50%;
    transform: translateX(-50%); width: max-content; max-width: 260px;
    background: var(--surface2); border: 1px solid var(--border); border-radius: 8px;
    padding: 8px 12px; font-size: 0.82rem; color: var(--text); line-height: 1.5;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4); z-index: 100; pointer-events: none;
  }
  .glossary-term:hover .glossary-tip,
  .glossary-term:focus .glossary-tip { display: block; }
  @media (max-width: 600px) {
    .glossary-tip { left: 0; transform: none; max-width: 220px; }
  }

  /* Bloch labels */
  .block-group-label {
    font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.08em;
    color: var(--text-dim); margin-bottom: 4px;
  }
  .block-group {
    border: 1px dashed var(--border); border-radius: 8px;
    padding: 8px; margin: 4px;
    display: inline-flex; flex-direction: column; align-items: center;
  }
  .block-group .qubit-row { margin: 0; }
  .block-group-a { background: rgba(248,113,113,0.06); border-color: rgba(248,113,113,0.25); }
  .block-group-b { background: rgba(96,165,250,0.06); border-color: rgba(96,165,250,0.25); }
  .block-group-c { background: rgba(167,139,250,0.06); border-color: rgba(167,139,250,0.25); }
  .block-group-a .block-group-label { color: #f87171; }
  .block-group-b .block-group-label { color: #60a5fa; }
  .block-group-c .block-group-label { color: #a78bfa; }

  /* Tab system */
  .tab-bar { display: flex; gap: 4px; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0; }
  .tab-btn {
    padding: 8px 16px; border: none; background: none; color: var(--text-dim);
    font-size: 0.85rem; cursor: pointer; border-bottom: 2px solid transparent;
    font-family: var(--font-sans); transition: all .2s; font-weight: 500;
  }
  .tab-btn:hover { color: var(--text); }
  .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* Error selector */
  .error-selector {
    display: flex; gap: 6px; flex-wrap: wrap; margin: 0.5rem 0;
  }
  .error-selector button.active { border-color: var(--red); color: var(--red); background: rgba(248,113,113,0.1); }

  .error-grid {
    display: grid; grid-template-columns: auto repeat(3, 1fr); gap: 6px; align-items: center;
    margin: 0.5rem 0; max-width: 360px; transition: opacity 0.2s ease;
  }
  .error-grid.tab-fading { opacity: 0; }
  .error-grid .block-label {
    font-size: 0.75rem; color: var(--text-dim); font-weight: 600; text-align: right; padding-right: 4px;
  }
  .error-grid .no-error-btn { grid-column: 1 / -1; }

  /* Syndrome decoder widget */
  .syndrome-toggle {
    width: 44px; height: 44px; border-radius: 50%; border: 2px solid var(--orange);
    background: transparent; color: var(--orange); font-size: 1.1rem; font-weight: 700;
    cursor: pointer; transition: background 0.15s, color 0.15s;
    display: inline-flex; align-items: center; justify-content: center;
  }
  .syndrome-toggle[aria-pressed="true"] {
    background: var(--orange); color: var(--bg);
  }
  .sd-highlight {
    border-color: var(--orange) !important; background: rgba(251,146,60,0.15) !important;
    box-shadow: 0 0 8px rgba(251,146,60,0.3);
  }

  /* Circuit gate highlights */
  .gate-highlight { filter: drop-shadow(0 0 6px rgba(108,140,255,0.8)); transition: filter 0.3s, opacity 0.3s; }
  .gate-dim { opacity: 0.25; transition: filter 0.3s, opacity 0.3s; }

  /* Progress bar for shor walkthrough */
  .progress-bar {
    width: 100%; height: 4px; background: var(--border); border-radius: 2px;
    margin: 0.5rem 0; overflow: hidden;
  }
  .progress-bar .fill {
    height: 100%; background: var(--accent); border-radius: 2px;
    transition: width 0.4s ease;
  }

  /* Comparison columns */
  .compare-cols {
    display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;
  }
  @media (max-width: 600px) { .compare-cols { grid-template-columns: 1fr; } }

  /* Particle background canvas */
  #particleBg {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: -1;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="particleBg"></canvas>
<a href="../index.html" style="position:fixed;top:1.2rem;left:1.5rem;z-index:1000;display:inline-flex;align-items:center;gap:0.4rem;color:var(--text-dim,#8892a8);text-decoration:none;font-family:'Inter',sans-serif;font-size:0.85rem;font-weight:500;padding:0.4rem 0.8rem;border-radius:8px;background:rgba(17,24,39,0.7);border:1px solid rgba(42,53,80,0.5);backdrop-filter:blur(8px);transition:all 0.2s;" onmouseover="this.style.color='#e2e8f0';this.style.borderColor='#6366f1'" onmouseout="this.style.color='#8892a8';this.style.borderColor='rgba(42,53,80,0.5)'"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>Course Home</a>

<a href="#intro" class="skip-link">Skip to content</a>

<nav role="navigation" aria-label="Main navigation">
  <div class="nav-inner">
    <span class="logo">QEC</span>
    <a href="#intro">Intro</a>
    <a href="#classical">Classical Code</a>
    <a href="#quantum-bitflip">Quantum Bit-Flip</a>
    <a href="#hadamard">Hadamard</a>
    <a href="#phase-flip">Phase-Flip</a>
    <a href="#shor">Shor's Code</a>
    <a href="#limitations">Limits</a>
    <a href="#summary">Summary</a>
  </div>
</nav>

<main>

<!-- ===================== INTRO ===================== -->
<section id="intro">
  <h1>Shor's 9-Qubit Code</h1>
  <p class="subtitle">An interactive guide to the first quantum error-correcting code — from classical bits to quantum fault tolerance.</p>

  <div class="card highlight">
    <p><strong>The central challenge:</strong> Quantum information is fragile. A single qubit can suffer bit-flip errors (<span class="gate gate-x">X</span>), phase-flip errors (<span class="gate gate-z">Z</span>), or any combination. Unlike classical bits, we cannot simply copy a qubit (the no-cloning theorem forbids it). Shor's 1995 code showed that quantum error correction is possible by encoding 1 logical qubit into 9 physical qubits.</p>
  </div>

  <div class="callout">
    <p><strong>Roadmap:</strong> We'll build understanding layer by layer:</p>
    <p>1. Classical 3-bit repetition code (corrects bit-flips)</p>
    <p>2. Quantum 3-qubit bit-flip code (quantum analogue)</p>
    <p>3. The Hadamard transform and its magic: turning phase-flips into bit-flips</p>
    <p>4. Quantum 3-qubit phase-flip code</p>
    <p>5. Shor's 9-qubit code: combining both</p>
  </div>
</section>

<!-- ===================== CLASSICAL ===================== -->
<section id="classical">
  <h2>1. Classical 3-Bit Repetition Code</h2>

  <p>The simplest error-correcting code: to protect a single bit, repeat it three times. If noise flips one bit, majority voting recovers the original.</p>

  <svg class="circuit-svg" viewBox="0 0 420 130" role="img" aria-label="Classical 3-bit repetition encoding circuit">
    <!-- Input wire -->
    <line x1="30" y1="65" x2="140" y2="65" stroke="#8b90a0" stroke-width="2"/>
    <!-- Fan-out node -->
    <circle cx="140" cy="65" r="6" fill="#6c8cff"/>
    <!-- Output wires -->
    <line x1="140" y1="65" x2="200" y2="25" stroke="#8b90a0" stroke-width="2"/>
    <line x1="140" y1="65" x2="200" y2="65" stroke="#8b90a0" stroke-width="2"/>
    <line x1="140" y1="65" x2="200" y2="105" stroke="#8b90a0" stroke-width="2"/>
    <line x1="200" y1="25" x2="390" y2="25" stroke="#8b90a0" stroke-width="2"/>
    <line x1="200" y1="65" x2="390" y2="65" stroke="#8b90a0" stroke-width="2"/>
    <line x1="200" y1="105" x2="390" y2="105" stroke="#8b90a0" stroke-width="2"/>
    <!-- Labels -->
    <text x="15" y="70" fill="#22d3ee" font-family="'Menlo',monospace" font-size="14" text-anchor="end">b</text>
    <text x="395" y="30" fill="#22d3ee" font-family="'Menlo',monospace" font-size="14">b</text>
    <text x="395" y="70" fill="#22d3ee" font-family="'Menlo',monospace" font-size="14">b</text>
    <text x="395" y="110" fill="#22d3ee" font-family="'Menlo',monospace" font-size="14">b</text>
    <text x="140" y="125" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="11" text-anchor="middle">COPY</text>
    <text x="400" y="125" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" opacity="0.5" text-anchor="end">Time →</text>
  </svg>

  <div class="interactive-panel" id="classical-panel">
    <div class="panel-title">Interactive: Classical Repetition Code</div>

    <div class="mb-1">
      <span class="hint-text">Choose your message bit:</span>
      <div class="btn-row">
        <button onclick="classicalSetBit(0)" id="cl-bit-0" class="primary">0</button>
        <button onclick="classicalSetBit(1)" id="cl-bit-1">1</button>
      </div>
    </div>

    <div>
      <span class="block-group-label">Original</span>
      <span class="arrow">&rarr;</span>
      <span class="block-group-label">Encoded (3 copies)</span>
      <span class="arrow">&rarr;</span>
      <span class="block-group-label">After noise</span>
      <span class="arrow">&rarr;</span>
      <span class="block-group-label">Decoded</span>
    </div>

    <div class="flex-row my-sm">
      <div class="qubit-box ket" id="cl-orig">0</div>
      <span class="arrow">&rarr;</span>
      <div class="qubit-box ket" id="cl-enc0">0</div>
      <div class="qubit-box ket" id="cl-enc1">0</div>
      <div class="qubit-box ket" id="cl-enc2">0</div>
      <span class="arrow">&rarr;</span>
      <div class="qubit-box" id="cl-noisy0">0</div>
      <div class="qubit-box" id="cl-noisy1">0</div>
      <div class="qubit-box" id="cl-noisy2">0</div>
      <span class="arrow">&rarr;</span>
      <div class="qubit-box" id="cl-decoded">0</div>
    </div>

    <div class="flex-row-tight my-sm">
      <span class="qubit-label">Syndrome:</span>
      <div class="qubit-box qubit-box-sm" id="cl-syn0">—</div>
      <div class="qubit-box qubit-box-sm" id="cl-syn1">—</div>
    </div>

    <div class="btn-row">
      <button class="danger" onclick="classicalFlip(0)">Flip bit 1</button>
      <button class="danger" onclick="classicalFlip(1)">Flip bit 2</button>
      <button class="danger" onclick="classicalFlip(2)">Flip bit 3</button>
      <button class="btn-orange" onclick="classicalFlip(Math.floor(Math.random()*3))">Random flip</button>
      <button onclick="classicalReset()">Reset</button>
    </div>

    <div class="step-description" id="cl-msg" aria-live="polite">
      Encode a bit and then flip one of the three copies. Majority vote will recover the original.
    </div>
  </div>

  <div class="card">
    <h3>How majority voting works</h3>
    <table>
      <tr><th>Received</th><th>Syndrome</th><th>Correction</th><th>Decoded</th></tr>
      <tr><td>000</td><td>No error</td><td>None</td><td>0</td></tr>
      <tr><td>001</td><td>Bit 3 flipped</td><td>Flip bit 3</td><td>0</td></tr>
      <tr><td>010</td><td>Bit 2 flipped</td><td>Flip bit 2</td><td>0</td></tr>
      <tr><td>100</td><td>Bit 1 flipped</td><td>Flip bit 1</td><td>0</td></tr>
      <tr><td>111</td><td>No error</td><td>None</td><td>1</td></tr>
      <tr><td>110</td><td>Bit 3 flipped</td><td>Flip bit 3</td><td>1</td></tr>
      <tr><td>101</td><td>Bit 2 flipped</td><td>Flip bit 2</td><td>1</td></tr>
      <tr><td>011</td><td>Bit 1 flipped</td><td>Flip bit 1</td><td>1</td></tr>
    </table>
    <p><strong>Key insight:</strong> We detect errors by comparing bits (computing the <em>syndrome</em>), not by looking at the value of any individual bit. This same principle extends to quantum codes.</p>
  </div>
</section>

  <details class="self-test">
    <summary>Self-test: Why can the 3-bit code correct 1 error but not 2?</summary>
    <div class="answer">With 2 flipped bits, the majority vote agrees with the <em>flipped</em> bits, not the original. For example, if we encode 0 as 000 and two bits flip to give 110, majority vote returns 1 (wrong). The code's <strong><span class="glossary-term" tabindex="0">distance<span class="glossary-tip">The minimum number of single-qubit errors needed to turn one valid codeword into another. A code with distance d can correct ⌊(d−1)/2⌋ errors.</span></span></strong> is 3 — it can detect up to $d-1=2$ errors but only correct $\lfloor(d-1)/2\rfloor = 1$.</div>
  </details>

  <details class="self-test">
    <summary>Self-test: What does the syndrome (1,0) tell us?</summary>
    <div class="answer">The syndrome is computed from parity checks: bit 1 XOR bit 2, and bit 2 XOR bit 3. Syndrome (1,0) means bits 1 and 2 disagree, but bits 2 and 3 agree. Since bit 2 and bit 3 agree with each other, bit 1 must be the one that flipped. The syndrome localizes the error without revealing the actual bit value.</div>
  </details>

<!-- ===================== QUANTUM BIT-FLIP ===================== -->
<section id="quantum-bitflip">
  <h2>2. Quantum 3-Qubit Bit-Flip Code</h2>

  <p>We can't clone a qubit, but we <em>can</em> entangle it with <span class="glossary-term" tabindex="0">ancilla<span class="glossary-tip">An extra "helper" qubit used to extract error information without disturbing the encoded data. Measured and discarded after syndrome extraction.</span></span> qubits. The encoding maps:</p>

  <div class="callout warn">
    <p><strong>The No-Cloning Theorem:</strong> It is mathematically impossible to create an exact copy of an unknown quantum state. If cloning were possible, we could violate the uncertainty principle and enable faster-than-light communication. This means quantum error correction must use <em>entanglement</em> rather than copying. The encoding $|\psi\rangle \to \alpha|000\rangle + \beta|111\rangle$ does <strong>not</strong> create three copies of $|\psi\rangle$ -- it creates an entangled state where no single qubit carries the full information about $\alpha$ and $\beta$.</p>
  </div>

  <div class="compare-cols my-md">
    <div class="card">
      <h3>Classical Repetition</h3>
      <ul>
        <li><strong>Encode:</strong> Copy the bit 3 times</li>
        <li><strong>Detect:</strong> Compare bits directly</li>
        <li><strong>Correct:</strong> Majority vote</li>
        <li><strong>Handles:</strong> Bit-flip errors only</li>
      </ul>
    </div>
    <div class="card">
      <h3>Quantum Bit-Flip</h3>
      <ul>
        <li><strong>Encode:</strong> Entangle with ancilla qubits</li>
        <li><strong>Detect:</strong> Syndrome (parity) checks</li>
        <li><strong>Correct:</strong> Apply correction gate</li>
        <li><strong>Handles:</strong> X errors only</li>
      </ul>
    </div>
  </div>

  <div class="math-block">
    $$|0\rangle \;\rightarrow\; |000\rangle$$
    $$|1\rangle \;\rightarrow\; |111\rangle$$
    $$\alpha|0\rangle + \beta|1\rangle \;\rightarrow\; \alpha|000\rangle + \beta|111\rangle$$
  </div>

  <svg class="circuit-svg" viewBox="0 0 500 160" role="img" aria-label="3-qubit bit-flip encoding circuit with CNOT gates">
    <!-- Qubit wires -->
    <line x1="70" y1="40" x2="460" y2="40" stroke="#8b90a0" stroke-width="2"/>
    <line x1="70" y1="80" x2="460" y2="80" stroke="#8b90a0" stroke-width="2"/>
    <line x1="70" y1="120" x2="460" y2="120" stroke="#8b90a0" stroke-width="2"/>
    <!-- Input labels -->
    <text x="60" y="45" fill="#22d3ee" font-family="'Menlo',monospace" font-size="13" text-anchor="end">|&psi;&rang;</text>
    <text x="60" y="85" fill="#8b90a0" font-family="'Menlo',monospace" font-size="13" text-anchor="end">|0&rang;</text>
    <text x="60" y="125" fill="#8b90a0" font-family="'Menlo',monospace" font-size="13" text-anchor="end">|0&rang;</text>
    <!-- CNOT 1: control on q1, target on q2 -->
    <g id="qbf-gate-cnot1">
    <title>CNOT: Flips target qubit q2 if control q1 is |1⟩</title>
    <line x1="200" y1="40" x2="200" y2="80" stroke="#6c8cff" stroke-width="2"/>
    <circle cx="200" cy="40" r="5" fill="#6c8cff"/>
    <circle cx="200" cy="80" r="12" fill="none" stroke="#6c8cff" stroke-width="2"/>
    <line x1="200" y1="68" x2="200" y2="92" stroke="#6c8cff" stroke-width="2"/>
    <line x1="188" y1="80" x2="212" y2="80" stroke="#6c8cff" stroke-width="2"/>
    </g>
    <!-- CNOT 2: control on q1, target on q3 -->
    <g id="qbf-gate-cnot2">
    <title>CNOT: Flips target qubit q3 if control q1 is |1⟩</title>
    <line x1="280" y1="40" x2="280" y2="120" stroke="#6c8cff" stroke-width="2"/>
    <circle cx="280" cy="40" r="5" fill="#6c8cff"/>
    <circle cx="280" cy="120" r="12" fill="none" stroke="#6c8cff" stroke-width="2"/>
    <line x1="280" y1="108" x2="280" y2="132" stroke="#6c8cff" stroke-width="2"/>
    <line x1="268" y1="120" x2="292" y2="120" stroke="#6c8cff" stroke-width="2"/>
    </g>
    <!-- Output labels -->
    <text x="395" y="150" fill="#22d3ee" font-family="system-ui,sans-serif" font-size="11" text-anchor="middle">&alpha;|000&rang; + &beta;|111&rang;</text>
    <!-- Gate labels -->
    <text x="200" y="14" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" text-anchor="middle">CNOT</text>
    <text x="280" y="14" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" text-anchor="middle">CNOT</text>
    <text x="480" y="155" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" opacity="0.5" text-anchor="end">Time →</text>
  </svg>

  <p>This is achieved with two <span class="glossary-term" tabindex="0">CNOT<span class="glossary-tip">Controlled-NOT gate: flips the target qubit if and only if the control qubit is |1⟩. The fundamental two-qubit gate for entangling and encoding.</span></span> gates. If a bit-flip (<span class="gate gate-x">X</span>) hits one qubit, we detect it using <strong><span class="glossary-term" tabindex="0">syndrome<span class="glossary-tip">A set of parity-check outcomes that identifies which error occurred, without revealing the encoded quantum information. Like an error fingerprint.</span></span> measurements</strong> — parity checks that reveal <em>which</em> qubit flipped without revealing &alpha; or &beta;.</p>

  <div class="interactive-panel" id="qbf-panel">
    <div class="panel-title">Interactive: Quantum Bit-Flip Code</div>

    <div class="mb-sm">
      <span class="hint-text">Logical qubit state: &alpha;|0&#10217; + &beta;|1&#10217;</span>
    </div>

    <div id="qbf-steps">
      <div class="state-flow" id="qbf-flow">
        <span class="flow-stage flow-active" data-step="0">|&psi;&#10217;</span><span class="flow-arrow">&#9654;</span>
        <span class="flow-stage" data-step="1">Encode</span><span class="flow-arrow">&#9654;</span>
        <span class="flow-stage" data-step="2">Error</span><span class="flow-arrow">&#9654;</span>
        <span class="flow-stage" data-step="3">Syndrome</span><span class="flow-arrow">&#9654;</span>
        <span class="flow-stage" data-step="4">Correct</span>
      </div>
      <div class="stepper-controls">
        <button onclick="qbfPrev()" id="qbf-prev-btn" disabled><span class="btn-icon">&larr;</span><span class="btn-text">&larr; Prev</span></button>
        <span class="step-counter" id="qbf-step-label">Step 1 / 5</span>
        <button onclick="qbfNext()" id="qbf-next-btn"><span class="btn-icon">&rarr;</span><span class="btn-text">Next &rarr;</span></button>
        <button onclick="qbfReset()" class="ml-auto">Reset</button>
      </div>
      <div class="progress-bar"><div class="fill" id="qbf-progress" style="width:20%"></div></div>
    </div>

    <div class="flex-row-tight my-md">
      <div class="qubit-box ket" id="qbf-q0">|&psi;&#10217;</div>
      <div class="qubit-box ket" id="qbf-q1">|0&#10217;</div>
      <div class="qubit-box ket" id="qbf-q2">|0&#10217;</div>
      <span class="qubit-label ml-sm">Syndrome:</span>
      <div class="qubit-box qubit-box-sm" id="qbf-s0">—</div>
      <div class="qubit-box qubit-box-sm" id="qbf-s1">—</div>
    </div>

    <div class="step-description" id="qbf-desc" aria-live="polite">
      <strong>Step 1 — Initial state:</strong> We have our logical qubit |&psi;&#10217; = &alpha;|0&#10217; + &beta;|1&#10217; and two ancilla qubits initialized to |0&#10217;. The full state is (&alpha;|0&#10217; + &beta;|1&#10217;) &otimes; |00&#10217;.
    </div>

    <div class="mt-1">
      <span class="hint-text">When you reach the error step, choose which qubit to hit:</span>
      <div class="error-selector disabled" id="qbf-error-sel">
        <button onclick="qbfSelectError(0)" id="qbf-e0" aria-pressed="false">X on qubit 1</button>
        <button onclick="qbfSelectError(1)" id="qbf-e1" aria-pressed="false">X on qubit 2</button>
        <button onclick="qbfSelectError(2)" id="qbf-e2" aria-pressed="false">X on qubit 3</button>
        <button onclick="qbfSelectError(-1)" id="qbf-en" aria-pressed="false">No error</button>
        <button class="btn-orange" onclick="qbfSelectError(Math.floor(Math.random()*4)-1)">Random</button>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Syndrome table for bit-flip code</h3>
    <table>
      <tr><th>Syndrome ($Z_1Z_2,\; Z_2Z_3$)</th><th>Error</th><th>Correction</th></tr>
      <tr><td>0, 0</td><td>None</td><td>None</td></tr>
      <tr><td>1, 0</td><td>X on qubit 1</td><td>Apply X to qubit 1</td></tr>
      <tr><td>1, 1</td><td>X on qubit 2</td><td>Apply X to qubit 2</td></tr>
      <tr><td>0, 1</td><td>X on qubit 3</td><td>Apply X to qubit 3</td></tr>
    </table>
    <p>The syndrome measurements check <strong>parity between adjacent qubits</strong> without collapsing the encoded state. This is the quantum magic: we learn <em>where</em> the error is, but nothing about &alpha; or &beta;.</p>
  </div>

  <div class="callout">
    <p><strong>How do we measure syndromes without disturbing the data?</strong> We use extra qubits called <strong>ancillas</strong> (from Latin <em>ancilla</em>, "helper"). The procedure works in three steps:</p>
    <ol>
      <li><strong>Prepare</strong> an ancilla qubit in state $|0\rangle$.</li>
      <li><strong>Entangle</strong> it with the data qubits using CNOT gates. For example, to measure $Z_1Z_2$ parity, apply CNOT from qubit 1 to the ancilla, then CNOT from qubit 2 to the ancilla. The ancilla now holds the parity $q_1 \oplus q_2$.</li>
      <li><strong>Measure</strong> only the ancilla. If it reads $|0\rangle$, parity is even (qubits agree); if $|1\rangle$, parity is odd (qubits disagree).</li>
    </ol>
    <p class="mt-sm hint-text">The data qubits are never measured directly — the ancilla absorbs only the parity information, leaving the superposition $\alpha$ and $\beta$ intact.</p>
  </div>

  <div class="card">
    <h3>Try it: syndrome decoder</h3>
    <p class="hint-text mb-sm">Toggle the two syndrome bits to see which qubit the decoder identifies as errored.</p>
    <div class="flex-center mb-sm">
      <span class="qubit-label">Syndrome:</span>
      <button class="syndrome-toggle" id="sd-s0" aria-pressed="false" aria-label="Syndrome bit 1: 0" onclick="sdToggle(0)">0</button>
      <button class="syndrome-toggle" id="sd-s1" aria-pressed="false" aria-label="Syndrome bit 2: 0" onclick="sdToggle(1)">1</button>
    </div>
    <div class="flex-center mb-sm">
      <div class="qubit-box" id="sd-q0">q1</div>
      <div class="qubit-box" id="sd-q1">q2</div>
      <div class="qubit-box" id="sd-q2">q3</div>
    </div>
    <p id="sd-result" aria-live="polite"><strong>Syndrome (0,1):</strong> Error on qubit 3 — apply X to qubit 3.</p>
  </div>

  <div class="callout warn">
    <p><strong>Limitation:</strong> This code only corrects bit-flip (X) errors. But qubits also suffer <strong>phase-flip (Z) errors</strong>, where |1&#10217; picks up a minus sign: |1&#10217; &rarr; &minus;|1&#10217;. The bit-flip code is completely blind to these!</p>
  </div>
</section>

  <details class="self-test">
    <summary>Self-test: Why can't we just measure the qubits to check for errors?</summary>
    <div class="answer">Measuring a qubit in the computational basis would collapse the superposition $\alpha|0\rangle + \beta|1\rangle$ to either $|0\rangle$ or $|1\rangle$, destroying the quantum information we're trying to protect. Syndrome measurements are cleverly designed to extract <em>only</em> parity information (which qubit differs from its neighbors) without learning anything about $\alpha$ or $\beta$. This is the key difference from classical error correction.</div>
  </details>

<!-- ===================== HADAMARD ===================== -->
<section id="hadamard">
  <h2>3. The Hadamard Transform: Changing the Nature of Errors</h2>

  <p>The Hadamard gate <span class="gate gate-h">H</span> is the key that connects bit-flips and phase-flips. It maps between the computational basis $\{|0\rangle, |1\rangle\}$ and the Hadamard basis $\{|+\rangle, |-\rangle\}$:</p>

  <div class="math-block">
    $$H|0\rangle = |+\rangle = \frac{|0\rangle + |1\rangle}{\sqrt{2}}$$
    $$H|1\rangle = |-\rangle = \frac{|0\rangle - |1\rangle}{\sqrt{2}}$$
  </div>

  <div class="card highlight">
    <h3>The crucial insight</h3>
    <p>In the Hadamard basis, the roles of X and Z are <strong>swapped</strong>:</p>
    <div class="compare-cols">
      <div>
        <p class="text-red"><strong>Bit-flip X:</strong></p>
        <p>$X|0\rangle = |1\rangle$<br>$X|1\rangle = |0\rangle$</p>
        <p class="mt-sm">In the $\{|+\rangle,|-\rangle\}$ basis:</p>
        <p>$X|+\rangle = |+\rangle$<br>$X|-\rangle = -|-\rangle$</p>
        <p class="text-orange">X acts like a <strong>phase-flip</strong> in the Hadamard basis!</p>
      </div>
      <div>
        <p class="text-purple"><strong>Phase-flip Z:</strong></p>
        <p>$Z|0\rangle = |0\rangle$<br>$Z|1\rangle = -|1\rangle$</p>
        <p class="mt-sm">In the $\{|+\rangle,|-\rangle\}$ basis:</p>
        <p>$Z|+\rangle = |-\rangle$<br>$Z|-\rangle = |+\rangle$</p>
        <p class="text-orange">Z acts like a <strong>bit-flip</strong> in the Hadamard basis!</p>
      </div>
    </div>
    <p>Mathematically: $HXH = Z$ and $HZH = X$</p>
  </div>

  <div class="card text-center">
    <h3>The Hadamard Matrix</h3>
    <div class="math-block">
      $$H = \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$
    </div>
    <p><strong>Key properties:</strong></p>
    <p>$H^2 = I$ — applying H twice gives back the original state (H is its own inverse)</p>
    <p>$H = H^\dagger$ — H is both unitary and Hermitian</p>
    <p>H is a <strong>Fourier transform</strong> on a single qubit — it rotates between conjugate bases</p>
  </div>

  <div class="interactive-panel" id="hadamard-panel">
    <div class="panel-title">Interactive: Hadamard Conjugation</div>
    <p class="helper-text">Apply H, then an error, then H again. Watch how the error type transforms.</p>

    <div class="hadamard-grid">
      <div class="text-center">
        <div class="block-group-label">Start</div>
        <div class="qubit-box ket qubit-box-md" id="had-start">|0&#10217;</div>
      </div>
      <div class="transform-arrow">&rarr;</div>
      <div class="text-center">
        <div class="block-group-label">After H</div>
        <div class="qubit-box ket qubit-box-md" id="had-after-h">|+&#10217;</div>
      </div>
    </div>

    <div class="btn-row justify-center">
      <button onclick="hadApply('X')" class="danger">Apply X error</button>
      <button onclick="hadApply('Z')" class="btn-purple">Apply Z error</button>
    </div>

    <div class="hadamard-grid" id="had-result-grid">
      <div class="text-center">
        <div class="block-group-label">After error</div>
        <div class="qubit-box error qubit-box-md" id="had-after-err">—</div>
      </div>
      <div class="transform-arrow">&rarr;</div>
      <div class="text-center">
        <div class="block-group-label">After final H</div>
        <div class="qubit-box corrected qubit-box-md" id="had-final">—</div>
      </div>
    </div>

    <div class="step-description min-h-50" id="had-msg" aria-live="polite">
      Choose an error to apply to |+&#10217; and see what happens when you transform back with H.
    </div>

    <div class="btn-row">
      <button onclick="hadReset()">Reset</button>
      <button onclick="hadToggleBasis()" id="had-basis-btn">Start with |1&#10217; instead</button>
    </div>
  </div>

  <div class="callout success">
    <p><strong>Why this matters for error correction:</strong> If we encode in the Hadamard basis (using |+&#10217; and |&minus;&#10217; instead of |0&#10217; and |1&#10217;), then a phase-flip error <em>looks like</em> a bit-flip error. So we can reuse the same repetition code structure to detect phase-flips! This is the key idea behind Shor's code.</p>
  </div>
</section>

  <details class="self-test">
    <summary>Self-test: If HXH = Z and HZH = X, what is HYH?</summary>
    <div class="answer">Since $Y = iXZ$, we get $HYH = H(iXZ)H = i(HXH)(HZH) = iZX$. Now $ZX = iY$ (verify by matrix multiplication), so $HYH = i \cdot iY = -Y$. The Hadamard conjugation sends $Y \to -Y$. Since a global phase of $-1$ is physically unobservable, Y errors are essentially unchanged under Hadamard conjugation.</div>
  </details>

  <details class="self-test">
    <summary>Self-test: Why is the Hadamard gate its own inverse?</summary>
    <div class="answer">You can verify directly: $H^2 = \frac{1}{2}\begin{pmatrix}1&1\\1&-1\end{pmatrix}\begin{pmatrix}1&1\\1&-1\end{pmatrix} = \frac{1}{2}\begin{pmatrix}2&0\\0&2\end{pmatrix} = I$. Geometrically, H is a reflection on the Bloch sphere (a 180-degree rotation about the axis halfway between X and Z). Any reflection applied twice is the identity.</div>
  </details>

<!-- ===================== PHASE-FLIP CODE ===================== -->
<section id="phase-flip">
  <h2>4. The 3-Qubit Phase-Flip Code</h2>

  <p>By encoding in the Hadamard basis, we can correct phase-flip errors using the same repetition structure:</p>

  <div class="math-block">
    $$|0\rangle \;\rightarrow\; |{+}{+}{+}\rangle = \left(\tfrac{|0\rangle+|1\rangle}{\sqrt{2}}\right)^{\otimes 3}$$
    $$|1\rangle \;\rightarrow\; |{-}{-}{-}\rangle = \left(\tfrac{|0\rangle-|1\rangle}{\sqrt{2}}\right)^{\otimes 3}$$
    $$\alpha|0\rangle + \beta|1\rangle \;\rightarrow\; \alpha|{+}{+}{+}\rangle + \beta|{-}{-}{-}\rangle$$
  </div>

  <p>The encoding circuit: first apply CNOTs (as in the bit-flip code), then apply <span class="gate gate-h">H</span> to each qubit:</p>

  <svg class="circuit-svg" viewBox="0 0 580 160" role="img" aria-label="3-qubit phase-flip encoding circuit with CNOT and Hadamard gates">
    <!-- Qubit wires -->
    <line x1="70" y1="40" x2="540" y2="40" stroke="#8b90a0" stroke-width="2"/>
    <line x1="70" y1="80" x2="540" y2="80" stroke="#8b90a0" stroke-width="2"/>
    <line x1="70" y1="120" x2="540" y2="120" stroke="#8b90a0" stroke-width="2"/>
    <!-- Input labels -->
    <text x="60" y="45" fill="#22d3ee" font-family="'Menlo',monospace" font-size="13" text-anchor="end">|&psi;&rang;</text>
    <text x="60" y="85" fill="#8b90a0" font-family="'Menlo',monospace" font-size="13" text-anchor="end">|0&rang;</text>
    <text x="60" y="125" fill="#8b90a0" font-family="'Menlo',monospace" font-size="13" text-anchor="end">|0&rang;</text>
    <!-- CNOT 1 -->
    <g id="pf-gate-cnot1">
    <title>CNOT: Entangles q1 and q2 for phase-flip encoding</title>
    <line x1="180" y1="40" x2="180" y2="80" stroke="#6c8cff" stroke-width="2"/>
    <circle cx="180" cy="40" r="5" fill="#6c8cff"/>
    <circle cx="180" cy="80" r="12" fill="none" stroke="#6c8cff" stroke-width="2"/>
    <line x1="180" y1="68" x2="180" y2="92" stroke="#6c8cff" stroke-width="2"/>
    <line x1="168" y1="80" x2="192" y2="80" stroke="#6c8cff" stroke-width="2"/>
    </g>
    <!-- CNOT 2 -->
    <g id="pf-gate-cnot2">
    <title>CNOT: Entangles q1 and q3 for phase-flip encoding</title>
    <line x1="250" y1="40" x2="250" y2="120" stroke="#6c8cff" stroke-width="2"/>
    <circle cx="250" cy="40" r="5" fill="#6c8cff"/>
    <circle cx="250" cy="120" r="12" fill="none" stroke="#6c8cff" stroke-width="2"/>
    <line x1="250" y1="108" x2="250" y2="132" stroke="#6c8cff" stroke-width="2"/>
    <line x1="238" y1="120" x2="262" y2="120" stroke="#6c8cff" stroke-width="2"/>
    </g>
    <!-- Separator -->
    <line x1="320" y1="10" x2="320" y2="145" stroke="#2e3345" stroke-width="1" stroke-dasharray="4,4"/>
    <!-- H gates -->
    <g id="pf-gate-h123">
    <title>Hadamard gates: Switch all 3 qubits to the |+⟩/|−⟩ basis for phase-flip protection</title>
    <!-- H gate on q1 -->
    <rect x="370" y="24" width="30" height="30" rx="4" fill="#1a1d27" stroke="#22d3ee" stroke-width="2"/>
    <text x="385" y="44" fill="#22d3ee" font-family="'Menlo',monospace" font-size="14" font-weight="bold" text-anchor="middle">H</text>
    <!-- H gate on q2 -->
    <rect x="370" y="64" width="30" height="30" rx="4" fill="#1a1d27" stroke="#22d3ee" stroke-width="2"/>
    <text x="385" y="84" fill="#22d3ee" font-family="'Menlo',monospace" font-size="14" font-weight="bold" text-anchor="middle">H</text>
    <!-- H gate on q3 -->
    <rect x="370" y="104" width="30" height="30" rx="4" fill="#1a1d27" stroke="#22d3ee" stroke-width="2"/>
    <text x="385" y="124" fill="#22d3ee" font-family="'Menlo',monospace" font-size="14" font-weight="bold" text-anchor="middle">H</text>
    </g>
    <!-- Stage labels -->
    <text x="215" y="155" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" text-anchor="middle">Bit-flip encoding</text>
    <text x="385" y="155" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" text-anchor="middle">Basis change</text>
    <!-- Output labels -->
    <text x="545" y="45" fill="#22d3ee" font-family="'Menlo',monospace" font-size="11">|+/-&rang;</text>
    <text x="545" y="85" fill="#22d3ee" font-family="'Menlo',monospace" font-size="11">|+/-&rang;</text>
    <text x="545" y="125" fill="#22d3ee" font-family="'Menlo',monospace" font-size="11">|+/-&rang;</text>
    <text x="560" y="155" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" opacity="0.5" text-anchor="end">Time →</text>
  </svg>

  <p>A phase-flip Z on any single qubit is detected via syndrome measurements in the X-basis (measuring $X_1X_2$ and $X_2X_3$).</p>

  <div class="interactive-panel" id="pf-panel">
    <div class="panel-title">Interactive: Phase-Flip Code</div>

    <div class="state-flow" id="pf-flow">
      <span class="flow-stage flow-active" data-step="0">|&psi;&#10217;</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="1">Encode</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="2">Error</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="3">Syndrome</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="4">Correct</span>
    </div>

    <div class="stepper-controls">
      <button onclick="pfPrev()" id="pf-prev-btn" disabled><span class="btn-icon">&larr;</span><span class="btn-text">&larr; Prev</span></button>
      <span class="step-counter" id="pf-step-label">Step 1 / 5</span>
      <button onclick="pfNext()" id="pf-next-btn"><span class="btn-icon">&rarr;</span><span class="btn-text">Next &rarr;</span></button>
      <button onclick="pfReset()" class="ml-auto">Reset</button>
    </div>
    <div class="progress-bar"><div class="fill" id="pf-progress" style="width:20%"></div></div>

    <div class="flex-row-tight my-md">
      <div class="qubit-box ket" id="pf-q0">|&psi;&#10217;</div>
      <div class="qubit-box ket" id="pf-q1">|0&#10217;</div>
      <div class="qubit-box ket" id="pf-q2">|0&#10217;</div>
      <span class="qubit-label ml-sm">Syndrome:</span>
      <div class="qubit-box qubit-box-sm" id="pf-s0">—</div>
      <div class="qubit-box qubit-box-sm" id="pf-s1">—</div>
    </div>

    <div class="step-description" id="pf-desc" aria-live="polite">
      <strong>Step 1 — Initial state:</strong> We start with |&psi;&#10217; = &alpha;|0&#10217; + &beta;|1&#10217; and two ancillas |0&#10217;.
    </div>

    <div class="mt-1">
      <span class="hint-text">When you reach the error step, choose which qubit to hit:</span>
      <div class="error-selector disabled" id="pf-error-sel">
        <button onclick="pfSelectError(0)" id="pf-e0" aria-pressed="false">Z on qubit 1</button>
        <button onclick="pfSelectError(1)" id="pf-e1" aria-pressed="false">Z on qubit 2</button>
        <button onclick="pfSelectError(2)" id="pf-e2" aria-pressed="false">Z on qubit 3</button>
        <button onclick="pfSelectError(-1)" id="pf-en" aria-pressed="false">No error</button>
        <button class="btn-orange" onclick="pfSelectError(Math.floor(Math.random()*4)-1)">Random</button>
      </div>
    </div>
  </div>

  <div class="compare-cols">
    <div class="card">
      <h3 class="text-red">Bit-flip code</h3>
      <p>Encodes: $|0\rangle\!\to\!|000\rangle$, $|1\rangle\!\to\!|111\rangle$</p>
      <p>Corrects: X errors</p>
      <p>Syndrome: Z-basis parities</p>
      <p>Blind to: Z errors</p>
    </div>
    <div class="card">
      <h3 class="text-purple">Phase-flip code</h3>
      <p>Encodes: $|0\rangle\!\to\!|{+}{+}{+}\rangle$, $|1\rangle\!\to\!|{-}{-}{-}\rangle$</p>
      <p>Corrects: Z errors</p>
      <p>Syndrome: X-basis parities</p>
      <p>Blind to: X errors</p>
    </div>
  </div>

  <div class="callout">
    <p><strong>Shor's idea:</strong> What if we use <em>both</em> codes together? Encode each qubit of the phase-flip code using the bit-flip code. This gives a 9-qubit code that corrects both X and Z errors — and therefore <em>any</em> single-qubit error!</p>
  </div>
</section>

  <details class="self-test">
    <summary>Self-test: Why does the phase-flip code use X-basis syndrome measurements?</summary>
    <div class="answer">The phase-flip code encodes in the Hadamard basis: $|0\rangle_L = |{+}{+}{+}\rangle$, $|1\rangle_L = |{-}{-}{-}\rangle$. A Z error flips $|+\rangle \leftrightarrow |-\rangle$, which looks like a bit-flip <em>in the Hadamard basis</em>. To detect this, we need parity checks in the X-basis (measuring $X_iX_j$), which check whether adjacent qubits agree in the $\{|+\rangle,|-\rangle\}$ basis. Using Z-basis measurements would tell us about the computational basis, where the encoded state looks like a complicated superposition — we'd learn nothing useful and would collapse the state.</div>
  </details>

<!-- ===================== SHOR'S CODE ===================== -->
<section id="shor">
  <h2>5. Shor's 9-Qubit Code</h2>

  <p>Shor's code is a <strong><span class="glossary-term" tabindex="0">concatenation<span class="glossary-tip">Building a larger code by nesting one code inside another. Shor's code nests the 3-qubit bit-flip code inside the 3-qubit phase-flip code, yielding 9 qubits total.</span></span></strong> of the phase-flip code (outer) and the bit-flip code (inner). The encoding is:</p>

  <div class="math-block">
    $$|0\rangle_L = \frac{(|000\rangle + |111\rangle)(|000\rangle + |111\rangle)(|000\rangle + |111\rangle)}{2\sqrt{2}}$$
    $$|1\rangle_L = \frac{(|000\rangle - |111\rangle)(|000\rangle - |111\rangle)(|000\rangle - |111\rangle)}{2\sqrt{2}}$$
  </div>

  <div class="card">
    <h3>Structure: two layers of protection</h3>
    <p>The 9 qubits are organized into <strong>3 blocks of 3</strong>:</p>
    <div class="flex-center my-md">
      <div class="block-group block-group-a">
        <div class="block-group-label">Block A (qubits 1-3)</div>
        <div class="qubit-row justify-center">
          <div class="qubit-box ket qubit-box-label">q1</div>
          <div class="qubit-box ket qubit-box-label">q2</div>
          <div class="qubit-box ket qubit-box-label">q3</div>
        </div>
      </div>
      <div class="block-group block-group-b">
        <div class="block-group-label">Block B (qubits 4-6)</div>
        <div class="qubit-row justify-center">
          <div class="qubit-box ket qubit-box-label">q4</div>
          <div class="qubit-box ket qubit-box-label">q5</div>
          <div class="qubit-box ket qubit-box-label">q6</div>
        </div>
      </div>
      <div class="block-group block-group-c">
        <div class="block-group-label">Block C (qubits 7-9)</div>
        <div class="qubit-row justify-center">
          <div class="qubit-box ket qubit-box-label">q7</div>
          <div class="qubit-box ket qubit-box-label">q8</div>
          <div class="qubit-box ket qubit-box-label">q9</div>
        </div>
      </div>
    </div>
    <!-- Concatenation hierarchy diagram -->
    <svg class="circuit-svg" viewBox="0 0 700 220" role="img" aria-label="Shor code concatenation: 1 logical qubit to 3 blocks to 9 physical qubits">
      <!-- Top: logical qubit -->
      <rect x="310" y="10" width="80" height="32" rx="8" fill="#1a1d27" stroke="#6c8cff" stroke-width="2"/>
      <text x="350" y="31" fill="#6c8cff" font-family="system-ui,sans-serif" font-size="12" font-weight="600" text-anchor="middle">1 Logical</text>
      <!-- Lines down to blocks -->
      <line x1="350" y1="42" x2="120" y2="80" stroke="#a78bfa" stroke-width="2"/>
      <line x1="350" y1="42" x2="350" y2="80" stroke="#a78bfa" stroke-width="2"/>
      <line x1="350" y1="42" x2="580" y2="80" stroke="#a78bfa" stroke-width="2"/>
      <!-- Phase-flip label -->
      <text x="350" y="68" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="10" text-anchor="middle">Phase-flip code</text>
      <!-- Middle: 3 blocks -->
      <rect x="75" y="80" width="90" height="32" rx="8" fill="#1a1d27" stroke="#a78bfa" stroke-width="2"/>
      <text x="120" y="101" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="11" font-weight="600" text-anchor="middle">Block A</text>
      <rect x="305" y="80" width="90" height="32" rx="8" fill="#1a1d27" stroke="#a78bfa" stroke-width="2"/>
      <text x="350" y="101" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="11" font-weight="600" text-anchor="middle">Block B</text>
      <rect x="535" y="80" width="90" height="32" rx="8" fill="#1a1d27" stroke="#a78bfa" stroke-width="2"/>
      <text x="580" y="101" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="11" font-weight="600" text-anchor="middle">Block C</text>
      <!-- Lines to physical qubits - Block A -->
      <line x1="120" y1="112" x2="60" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <line x1="120" y1="112" x2="120" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <line x1="120" y1="112" x2="180" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <!-- Lines to physical qubits - Block B -->
      <line x1="350" y1="112" x2="290" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <line x1="350" y1="112" x2="350" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <line x1="350" y1="112" x2="410" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <!-- Lines to physical qubits - Block C -->
      <line x1="580" y1="112" x2="520" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <line x1="580" y1="112" x2="580" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <line x1="580" y1="112" x2="640" y2="160" stroke="#f87171" stroke-width="1.5"/>
      <!-- Bit-flip label -->
      <text x="350" y="148" fill="#f87171" font-family="system-ui,sans-serif" font-size="10" text-anchor="middle">Bit-flip code (per block)</text>
      <!-- Physical qubits -->
      <circle cx="60" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="60" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q1</text>
      <circle cx="120" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="120" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q2</text>
      <circle cx="180" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="180" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q3</text>
      <circle cx="290" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="290" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q4</text>
      <circle cx="350" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="350" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q5</text>
      <circle cx="410" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="410" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q6</text>
      <circle cx="520" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="520" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q7</text>
      <circle cx="580" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="580" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q8</text>
      <circle cx="640" cy="168" r="10" fill="#1a1d27" stroke="#f87171" stroke-width="1.5"/><text x="640" y="172" fill="#f87171" font-size="9" font-family="'Menlo',monospace" text-anchor="middle">q9</text>
      <!-- Bottom label -->
      <text x="350" y="205" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="11" text-anchor="middle">9 Physical Qubits</text>
    </svg>

    <p><strong>Inner code (within each block):</strong> The 3-qubit repetition code protects against <span class="gate gate-x">X</span> (bit-flip) errors. Each block uses Z-parity checks.</p>
    <p><strong>Outer code (across blocks):</strong> The 3-block structure (in the Hadamard basis) protects against <span class="gate gate-z">Z</span> (phase-flip) errors. Cross-block X-parity checks detect which block was affected.</p>
  </div>

  <div class="card">
    <h3>Encoding circuit</h3>
    <p>The full encoding circuit has two stages: first the outer (phase-flip) code, then the inner (bit-flip) code within each block.</p>
    <svg class="circuit-svg" viewBox="0 0 820 380" role="img" aria-label="Shor 9-qubit encoding circuit showing phase-flip then bit-flip stages">
      <!-- Block backgrounds -->
      <rect x="55" y="10" width="750" height="105" rx="6" fill="rgba(167,139,250,0.04)" stroke="rgba(167,139,250,0.15)" stroke-width="1"/>
      <rect x="55" y="125" width="750" height="105" rx="6" fill="rgba(167,139,250,0.04)" stroke="rgba(167,139,250,0.15)" stroke-width="1"/>
      <rect x="55" y="245" width="750" height="105" rx="6" fill="rgba(167,139,250,0.04)" stroke="rgba(167,139,250,0.15)" stroke-width="1"/>
      <text x="62" y="28" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="10" opacity="0.6">Block A</text>
      <text x="62" y="143" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="10" opacity="0.6">Block B</text>
      <text x="62" y="263" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="10" opacity="0.6">Block C</text>
      <!-- 9 qubit wires -->
      <line x1="70" y1="40" x2="800" y2="40" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="65" x2="800" y2="65" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="90" x2="800" y2="90" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="155" x2="800" y2="155" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="180" x2="800" y2="180" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="205" x2="800" y2="205" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="270" x2="800" y2="270" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="295" x2="800" y2="295" stroke="#8b90a0" stroke-width="1.5"/>
      <line x1="70" y1="320" x2="800" y2="320" stroke="#8b90a0" stroke-width="1.5"/>
      <!-- Input labels -->
      <text x="63" y="44" fill="#22d3ee" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|&psi;&rang;</text>
      <text x="63" y="69" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <text x="63" y="94" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <text x="63" y="159" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <text x="63" y="184" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <text x="63" y="209" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <text x="63" y="274" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <text x="63" y="299" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <text x="63" y="324" fill="#8b90a0" font-family="'Menlo',monospace" font-size="11" text-anchor="end">|0&rang;</text>
      <!-- PHASE-FLIP STAGE: CNOT q1->q4, CNOT q1->q7 -->
      <g>
      <title>Phase-flip CNOTs: Spread |ψ⟩ across blocks A, B, C</title>
      <!-- CNOT q1->q4 -->
      <line x1="170" y1="40" x2="170" y2="155" stroke="#a78bfa" stroke-width="2"/>
      <circle cx="170" cy="40" r="4" fill="#a78bfa"/>
      <circle cx="170" cy="155" r="10" fill="none" stroke="#a78bfa" stroke-width="2"/>
      <line x1="170" y1="145" x2="170" y2="165" stroke="#a78bfa" stroke-width="2"/>
      <line x1="160" y1="155" x2="180" y2="155" stroke="#a78bfa" stroke-width="2"/>
      <!-- CNOT q1->q7 -->
      <line x1="230" y1="40" x2="230" y2="270" stroke="#a78bfa" stroke-width="2"/>
      <circle cx="230" cy="40" r="4" fill="#a78bfa"/>
      <circle cx="230" cy="270" r="10" fill="none" stroke="#a78bfa" stroke-width="2"/>
      <line x1="230" y1="260" x2="230" y2="280" stroke="#a78bfa" stroke-width="2"/>
      <line x1="220" y1="270" x2="240" y2="270" stroke="#a78bfa" stroke-width="2"/>
      </g>
      <!-- H gates on q1, q4, q7 -->
      <g>
      <title>Hadamard gates: Switch block-lead qubits to |+⟩/|−⟩ basis for phase-flip protection</title>
      <rect x="290" y="25" width="28" height="28" rx="4" fill="#1a1d27" stroke="#22d3ee" stroke-width="2"/>
      <text x="304" y="44" fill="#22d3ee" font-family="'Menlo',monospace" font-size="13" font-weight="bold" text-anchor="middle">H</text>
      <rect x="290" y="140" width="28" height="28" rx="4" fill="#1a1d27" stroke="#22d3ee" stroke-width="2"/>
      <text x="304" y="159" fill="#22d3ee" font-family="'Menlo',monospace" font-size="13" font-weight="bold" text-anchor="middle">H</text>
      <rect x="290" y="255" width="28" height="28" rx="4" fill="#1a1d27" stroke="#22d3ee" stroke-width="2"/>
      <text x="304" y="274" fill="#22d3ee" font-family="'Menlo',monospace" font-size="13" font-weight="bold" text-anchor="middle">H</text>
      </g>
      <!-- Stage separator -->
      <line x1="380" y1="5" x2="380" y2="355" stroke="#2e3345" stroke-width="1" stroke-dasharray="5,5"/>
      <!-- BIT-FLIP STAGE: CNOTs within each block -->
      <g>
      <title>Bit-flip CNOTs: Triplicate each block-lead qubit within its block for bit-flip protection</title>
      <!-- Block A: CNOT q1->q2, CNOT q1->q3 -->
      <line x1="440" y1="40" x2="440" y2="65" stroke="#f87171" stroke-width="2"/>
      <circle cx="440" cy="40" r="4" fill="#f87171"/>
      <circle cx="440" cy="65" r="10" fill="none" stroke="#f87171" stroke-width="2"/>
      <line x1="440" y1="55" x2="440" y2="75" stroke="#f87171" stroke-width="2"/>
      <line x1="430" y1="65" x2="450" y2="65" stroke="#f87171" stroke-width="2"/>
      <line x1="500" y1="40" x2="500" y2="90" stroke="#f87171" stroke-width="2"/>
      <circle cx="500" cy="40" r="4" fill="#f87171"/>
      <circle cx="500" cy="90" r="10" fill="none" stroke="#f87171" stroke-width="2"/>
      <line x1="500" y1="80" x2="500" y2="100" stroke="#f87171" stroke-width="2"/>
      <line x1="490" y1="90" x2="510" y2="90" stroke="#f87171" stroke-width="2"/>
      <!-- Block B: CNOT q4->q5, CNOT q4->q6 -->
      <line x1="440" y1="155" x2="440" y2="180" stroke="#f87171" stroke-width="2"/>
      <circle cx="440" cy="155" r="4" fill="#f87171"/>
      <circle cx="440" cy="180" r="10" fill="none" stroke="#f87171" stroke-width="2"/>
      <line x1="440" y1="170" x2="440" y2="190" stroke="#f87171" stroke-width="2"/>
      <line x1="430" y1="180" x2="450" y2="180" stroke="#f87171" stroke-width="2"/>
      <line x1="500" y1="155" x2="500" y2="205" stroke="#f87171" stroke-width="2"/>
      <circle cx="500" cy="155" r="4" fill="#f87171"/>
      <circle cx="500" cy="205" r="10" fill="none" stroke="#f87171" stroke-width="2"/>
      <line x1="500" y1="195" x2="500" y2="215" stroke="#f87171" stroke-width="2"/>
      <line x1="490" y1="205" x2="510" y2="205" stroke="#f87171" stroke-width="2"/>
      <!-- Block C: CNOT q7->q8, CNOT q7->q9 -->
      <line x1="440" y1="270" x2="440" y2="295" stroke="#f87171" stroke-width="2"/>
      <circle cx="440" cy="270" r="4" fill="#f87171"/>
      <circle cx="440" cy="295" r="10" fill="none" stroke="#f87171" stroke-width="2"/>
      <line x1="440" y1="285" x2="440" y2="305" stroke="#f87171" stroke-width="2"/>
      <line x1="430" y1="295" x2="450" y2="295" stroke="#f87171" stroke-width="2"/>
      <line x1="500" y1="270" x2="500" y2="320" stroke="#f87171" stroke-width="2"/>
      <circle cx="500" cy="270" r="4" fill="#f87171"/>
      <circle cx="500" cy="320" r="10" fill="none" stroke="#f87171" stroke-width="2"/>
      <line x1="500" y1="310" x2="500" y2="330" stroke="#f87171" stroke-width="2"/>
      <line x1="490" y1="320" x2="510" y2="320" stroke="#f87171" stroke-width="2"/>
      </g>
      <!-- Stage labels -->
      <text x="240" y="370" fill="#a78bfa" font-family="system-ui,sans-serif" font-size="11" text-anchor="middle">Phase-flip encoding</text>
      <text x="540" y="370" fill="#f87171" font-family="system-ui,sans-serif" font-size="11" text-anchor="middle">Bit-flip encoding</text>
      <text x="800" y="375" fill="#8b90a0" font-family="system-ui,sans-serif" font-size="10" opacity="0.5" text-anchor="end">Time →</text>
    </svg>
  </div>

  <div class="interactive-panel" id="shor-panel">
    <div class="panel-title">Interactive: Shor's 9-Qubit Code — Full Walkthrough</div>

    <div class="state-flow" id="shor-flow">
      <span class="flow-stage flow-active" data-step="0">|&psi;&#10217;</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="1">Phase enc.</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="2">Bit enc.</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="3">Error</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="4">BF syn.</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="5">PF syn.</span><span class="flow-arrow">&#9654;</span>
      <span class="flow-stage" data-step="6">Correct</span>
    </div>

    <div class="stepper-controls">
      <button onclick="shorPrev()" id="shor-prev-btn" disabled><span class="btn-icon">&larr;</span><span class="btn-text">&larr; Prev</span></button>
      <span class="step-counter" id="shor-step-label">Step 1 / 7</span>
      <button onclick="shorNext()" id="shor-next-btn"><span class="btn-icon">&rarr;</span><span class="btn-text">Next &rarr;</span></button>
      <button onclick="shorReset()" class="ml-auto">Reset</button>
    </div>
    <div class="progress-bar"><div class="fill" id="shor-progress" style="width:14.3%"></div></div>

    <div class="flex-center-tight my-md" id="shor-qubits">
      <div class="block-group block-group-a" id="shor-block-a">
        <div class="block-group-label">Block A</div>
        <div class="qubit-row justify-center">
          <div class="qubit-box ket" id="sq0">|&psi;&#10217;</div>
          <div class="qubit-box ket" id="sq1">|0&#10217;</div>
          <div class="qubit-box ket" id="sq2">|0&#10217;</div>
        </div>
      </div>
      <div class="block-group block-group-b" id="shor-block-b">
        <div class="block-group-label">Block B</div>
        <div class="qubit-row justify-center">
          <div class="qubit-box ket" id="sq3">|0&#10217;</div>
          <div class="qubit-box ket" id="sq4">|0&#10217;</div>
          <div class="qubit-box ket" id="sq5">|0&#10217;</div>
        </div>
      </div>
      <div class="block-group block-group-c" id="shor-block-c">
        <div class="block-group-label">Block C</div>
        <div class="qubit-row justify-center">
          <div class="qubit-box ket" id="sq6">|0&#10217;</div>
          <div class="qubit-box ket" id="sq7">|0&#10217;</div>
          <div class="qubit-box ket" id="sq8">|0&#10217;</div>
        </div>
      </div>
    </div>

    <div class="flex-row my-sm">
      <span class="qubit-label">Bit-flip syndrome:</span>
      <div class="qubit-box qubit-box-wide" id="shor-bfs">—</div>
      <span class="qubit-label ml-xs">Phase-flip syndrome:</span>
      <div class="qubit-box qubit-box-wide" id="shor-pfs">—</div>
    </div>

    <div class="step-description" id="shor-desc" aria-live="polite">
      <strong>Step 1 — Initial state:</strong> Our logical qubit |&psi;&#10217; = &alpha;|0&#10217; + &beta;|1&#10217; is in qubit 1. All other 8 qubits are |0&#10217;.
    </div>

    <div class="mt-1" id="shor-error-section">
      <span class="hint-text">Choose an error (available at the error step):</span>
      <div class="tab-bar" id="shor-err-tabs">
        <button class="tab-btn active" onclick="shorErrTab('X')">Bit-flip (X)</button>
        <button class="tab-btn" onclick="shorErrTab('Z')">Phase-flip (Z)</button>
        <button class="tab-btn" onclick="shorErrTab('Y')">Both (Y = iXZ)</button>
      </div>
      <div class="error-grid error-selector disabled" id="shor-error-sel">
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Error correction procedure</h3>
    <p><strong>Step 1: Detect bit-flip errors (within each block).</strong> Measure $Z_iZ_j$ parity checks for each block. This identifies which qubit (if any) within a block has flipped. Apply X to correct.</p>
    <p><strong>Step 2: Detect phase-flip errors (across blocks).</strong> Measure the 6-qubit operators $X_1X_2X_3X_4X_5X_6$ and $X_4X_5X_6X_7X_8X_9$. This identifies which block (if any) has a sign flip. Apply Z to any qubit in that block to correct.</p>
  </div>

  <div class="card highlight">
    <h3>Why this corrects <em>any</em> single-qubit error</h3>
    <p>Any single-qubit error can be decomposed as a linear combination of I, X, Z, and Y = iXZ. When we measure the syndrome, the state collapses into one of these cases:</p>
    <table>
      <tr><th>Error</th><th>Bit-flip syndrome</th><th>Phase-flip syndrome</th><th>Correction</th></tr>
      <tr><td>I (no error)</td><td>All 0</td><td>All 0</td><td>None</td></tr>
      <tr><td>X on qubit k</td><td>Identifies k within block</td><td>All 0</td><td>Apply X<sub>k</sub></td></tr>
      <tr><td>Z on qubit k</td><td>All 0</td><td>Identifies block</td><td>Apply Z<sub>k</sub></td></tr>
      <tr><td>Y on qubit k</td><td>Identifies k within block</td><td>Identifies block</td><td>Apply Y<sub>k</sub></td></tr>
    </table>
    <p>The measurement <em>projects</em> the error into one of these discrete cases, and then we apply the appropriate correction. This is the <strong>digitization of errors</strong> — continuous errors become discrete through measurement.</p>
  </div>
</section>

  <details class="self-test">
    <summary>Self-test: Why does Shor's code need 9 qubits, not 6?</summary>
    <div class="answer">You might think: 3 qubits for bit-flip protection + 3 for phase-flip = 6. But the two codes can't simply run side by side — they'd each protect against only one error type. Shor's insight is <strong>concatenation</strong>: each of the 3 qubits in the phase-flip code is itself encoded using the 3-qubit bit-flip code, giving $3 \times 3 = 9$. This nesting ensures that bit-flip errors are caught within each block, and phase-flip errors are caught across blocks. (Later, the 7-qubit Steane code and 5-qubit perfect code showed that fewer qubits suffice.)</div>
  </details>

  <details class="self-test">
    <summary>Self-test: What happens to both syndromes when a Y error occurs?</summary>
    <div class="answer">A Y error equals $iXZ$: it's simultaneously a bit-flip and a phase-flip. The bit-flip syndrome detects the X component (identifying the specific qubit within its block), and the phase-flip syndrome detects the Z component (identifying which block). Both syndromes are nonzero, and together they uniquely identify the affected qubit. The correction is to apply $Y = iXZ$ to that qubit (or equivalently, apply X then Z). Try it in the interactive demo above!</div>
  </details>

<!-- ===================== LIMITATIONS ===================== -->
<section id="limitations" class="animate-in">
  <h2>6. When the Code Fails: Understanding Limits</h2>

  <p>Shor's code can correct any <strong>single</strong>-qubit error, but what happens when two or more qubits are hit? With distance $d = 3$, the decoder's assumption — at most one error — breaks down, and it can misidentify the problem.</p>

  <div class="card">
    <h3>Try it: multi-error failure modes</h3>
    <p class="hint-text mb-sm">Toggle X errors on the 3 qubits of a bit-flip block. Watch how the syndrome misleads the decoder when multiple errors occur.</p>

    <div class="flex-center mb-sm">
      <div class="qubit-box" id="lim-q0" onclick="limToggle(0)" role="button" tabindex="0" aria-pressed="false" aria-label="Qubit 1: no error">|ψ⟩</div>
      <div class="qubit-box" id="lim-q1" onclick="limToggle(1)" role="button" tabindex="0" aria-pressed="false" aria-label="Qubit 2: no error">|ψ⟩</div>
      <div class="qubit-box" id="lim-q2" onclick="limToggle(2)" role="button" tabindex="0" aria-pressed="false" aria-label="Qubit 3: no error">|ψ⟩</div>
    </div>

    <div class="flex-center mb-sm">
      <span class="qubit-label">Syndrome:</span>
      <span class="qubit-box syndrome" id="lim-s0">0</span>
      <span class="qubit-box syndrome" id="lim-s1">0</span>
    </div>

    <div id="lim-result" class="callout success" aria-live="polite">
      <p><strong>No errors.</strong> Syndrome (0,0) — the decoder sees no problem.</p>
    </div>
  </div>

  <div class="card">
    <h3>Beyond Shor's code</h3>
    <p>Shor's 9-qubit code was the first quantum error-correcting code, but it is far from optimal. Later discoveries reduced the qubit overhead and increased error tolerance:</p>
    <ul>
      <li><strong>Steane code</strong> $[[7,1,3]]$ — corrects the same errors with only 7 qubits using CSS construction</li>
      <li><strong>Perfect 5-qubit code</strong> $[[5,1,3]]$ — the smallest possible single-error-correcting code</li>
      <li><strong>Surface codes</strong> — the leading approach for real hardware, achieving high distance with nearest-neighbor qubits on a 2D grid</li>
    </ul>
    <p class="mt-sm hint-text">All share the same core principles we've explored: encode redundantly, measure syndromes without disturbing data, and correct based on the syndrome pattern.</p>
  </div>
</section>

<!-- ===================== SUMMARY ===================== -->
<section id="summary">
  <h2>7. Summary & Key Takeaways</h2>

  <div class="card">
    <h3>The three big ideas</h3>
    <p><strong>1. Redundancy without cloning:</strong> We can't copy quantum states, but we can spread quantum information across entangled qubits. The encoding creates a code space where errors move the state out of the code space in detectable ways.</p>
    <p><strong>2. The Hadamard duality:</strong> The Hadamard gate swaps X &#8596; Z errors. A phase-flip code is just a bit-flip code conjugated by H. This is a deep consequence of the structure of quantum mechanics — the X and Z bases are related by Fourier transform.</p>
    <p><strong>3. Code concatenation:</strong> By nesting the bit-flip code inside the phase-flip code (or vice versa), Shor's code corrects both types of errors — and therefore any single-qubit error. The syndrome measurement discretizes continuous errors.</p>
  </div>

  <div class="card">
    <h3>Code parameters</h3>
    <table>
      <tr><th>Property</th><th>Value</th></tr>
      <tr><td>Physical qubits</td><td>9</td></tr>
      <tr><td>Logical qubits</td><td>1</td></tr>
      <tr><td>Distance</td><td>3</td></tr>
      <tr><td>Correctable errors</td><td>Any single-qubit error (X, Z, or Y)</td></tr>
      <tr><td>Notation</td><td>[[9, 1, 3]]</td></tr>
      <tr><td>Stabilizer generators</td><td>8 (= 9 - 1)</td></tr>
    </table>
  </div>

  <div class="callout">
    <p><strong>Understanding code distance.</strong> The notation $[[n, k, d]]$ describes a quantum code encoding $k$ logical qubits into $n$ physical qubits with distance $d$. The <strong>distance</strong> is the minimum number of single-qubit operations needed to convert one valid codeword into another.</p>
    <p class="mt-sm">For Shor's $[[9,1,3]]$ code, distance $d = 3$ means:</p>
    <ul>
      <li><strong>Correct</strong> any $\lfloor (d{-}1)/2 \rfloor = 1$ error</li>
      <li><strong>Detect</strong> up to $d - 1 = 2$ errors (but cannot correct both)</li>
    </ul>
    <p class="mt-sm hint-text">This is a fundamental trade-off: higher distance costs more physical qubits but protects against more errors. The surface code, for example, achieves distance $d$ using roughly $2d^2$ physical qubits.</p>
  </div>

  <div class="card">
    <h3>What are stabilizers?</h3>
    <p>A <strong><span class="glossary-term" tabindex="0">stabilizer<span class="glossary-tip">An operator that leaves every valid codeword unchanged. Measuring stabilizers extracts error syndromes without collapsing the encoded information.</span></span></strong> is an operator that leaves every valid codeword unchanged: if $|\psi\rangle$ is in the code space, then $S|\psi\rangle = |\psi\rangle$. Think of stabilizers as <em>membership checks</em> — they verify that a state belongs to the code space without disturbing it.</p>
    <p class="mt-sm">When an error $E$ occurs, some stabilizers will <em>anti-commute</em> with it. Measuring those stabilizers returns $-1$ instead of $+1$, forming a pattern called the <strong>syndrome</strong>. Each correctable error produces a unique syndrome, so the decoder can identify and reverse the error:</p>
    <div class="math-block my-sm">$$\text{syndrome} \;\xrightarrow{\text{lookup}}\; \text{error } E \;\xrightarrow{\text{apply } E}\; \text{correction}$$</div>
    <p>Shor's code has 8 stabilizer generators (since $n - k = 9 - 1 = 8$), producing an 8-bit syndrome. Six use $Z$ operators for bit-flip detection within blocks; two use $X$ operators for phase-flip detection between blocks.</p>
  </div>

  <div class="card">
    <h3>Stabilizer generators</h3>
    <table class="table-auto-center">
      <tr><th class="th-center">Generator</th><th>Role</th></tr>
      <tr><td>$Z_1 Z_2$</td><td>Block A, qubits 1-2 parity</td></tr>
      <tr><td>$Z_2 Z_3$</td><td>Block A, qubits 2-3 parity</td></tr>
      <tr><td>$Z_4 Z_5$</td><td>Block B, qubits 4-5 parity</td></tr>
      <tr><td>$Z_5 Z_6$</td><td>Block B, qubits 5-6 parity</td></tr>
      <tr><td>$Z_7 Z_8$</td><td>Block C, qubits 7-8 parity</td></tr>
      <tr><td>$Z_8 Z_9$</td><td>Block C, qubits 8-9 parity</td></tr>
      <tr><td>$X_1 X_2 X_3 X_4 X_5 X_6$</td><td>Block A-B parity</td></tr>
      <tr><td>$X_4 X_5 X_6 X_7 X_8 X_9$</td><td>Block B-C parity</td></tr>
    </table>
  </div>

  <div class="callout success">
    <p><strong>Historical significance:</strong> Peter Shor published this code in 1995, disproving the widespread belief that quantum error correction was impossible. It paved the way for the theory of fault-tolerant quantum computation and all modern quantum error-correcting codes (CSS codes, surface codes, etc.).</p>
  </div>
</section>

</main>

<script>
// ============================================================
//  UTILITY: set HTML content and re-render KaTeX
// ============================================================
function updateStateFlow(flowId, currentStep) {
  const stages = document.querySelectorAll(`#${flowId} .flow-stage`);
  stages.forEach(s => {
    const step = parseInt(s.dataset.step);
    s.classList.toggle('flow-done', step < currentStep);
    s.classList.toggle('flow-active', step === currentStep);
  });
}

function setDescWithMath(id, html) {
  const el = document.getElementById(id);
  el.innerHTML = html;
  try {
    if (window.renderMathInElement) {
      renderMathInElement(el, {delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}]});
    }
  } catch (e) { console.warn('KaTeX render error in', id, e); }
}

// ============================================================
//  CIRCUIT GATE HIGHLIGHT HELPER
// ============================================================
function highlightGates(prefix, activeIds) {
  // Get all gate groups for this circuit prefix
  const allGates = document.querySelectorAll(`[id^="${prefix}-gate-"]`);
  if (allGates.length === 0) return;
  if (activeIds.length === 0) {
    // Clear all highlights
    allGates.forEach(g => { g.classList.remove('gate-highlight', 'gate-dim'); });
  } else {
    allGates.forEach(g => {
      const id = g.id.replace(prefix + '-gate-', '');
      if (activeIds.includes(id)) {
        g.classList.add('gate-highlight');
        g.classList.remove('gate-dim');
      } else {
        g.classList.add('gate-dim');
        g.classList.remove('gate-highlight');
      }
    });
  }
}

// ============================================================
//  CLASSICAL 3-BIT CODE
// ============================================================
const clState = { bit: 0, encoded: [0,0,0], noisy: [0,0,0] };

function classicalSetBit(b) {
  clState.bit = b;
  clState.encoded = [b, b, b];
  clState.noisy = [b, b, b];
  document.getElementById('cl-bit-0').classList.toggle('primary', b === 0);
  document.getElementById('cl-bit-1').classList.toggle('primary', b === 1);
  classicalRender();
  document.getElementById('cl-msg').innerHTML =
    `Bit <strong>${b}</strong> encoded as <strong>${b}${b}${b}</strong>. Now try flipping one bit!`;
}

function classicalFlip(i) {
  clState.noisy[i] ^= 1;
  classicalRender();
  const flips = clState.noisy.filter((v, j) => v !== clState.encoded[j]).length;
  if (flips <= 1) {
    document.getElementById('cl-msg').innerHTML =
      `Bit ${i+1} flipped! Majority vote: <strong>${majority(clState.noisy)}</strong> — error corrected! &#10003;`;
  } else {
    document.getElementById('cl-msg').innerHTML =
      `<span style="color:var(--red)">${flips} bits flipped — too many errors! Majority vote gives <strong>${majority(clState.noisy)}</strong>, which is wrong.</span>`;
  }
}

function majority(arr) {
  return arr[0] + arr[1] + arr[2] >= 2 ? 1 : 0;
}

function classicalRender() {
  document.getElementById('cl-orig').textContent = clState.bit;
  for (let i = 0; i < 3; i++) {
    document.getElementById('cl-enc' + i).textContent = clState.encoded[i];
    const nb = document.getElementById('cl-noisy' + i);
    nb.textContent = clState.noisy[i];
    nb.className = 'qubit-box' + (clState.noisy[i] !== clState.encoded[i] ? ' error' : ' ket');
  }
  // Syndrome: XOR of adjacent pairs
  const syn0 = clState.noisy[0] ^ clState.noisy[1];
  const syn1 = clState.noisy[1] ^ clState.noisy[2];
  const s0el = document.getElementById('cl-syn0');
  const s1el = document.getElementById('cl-syn1');
  s0el.textContent = syn0; s1el.textContent = syn1;
  s0el.className = 'qubit-box' + (syn0 ? ' syndrome' : '');
  s1el.className = 'qubit-box' + (syn1 ? ' syndrome' : '');

  const dec = document.getElementById('cl-decoded');
  const m = majority(clState.noisy);
  dec.textContent = m;
  dec.className = 'qubit-box' + (m === clState.bit ? ' corrected' : ' error');
}

function classicalReset() {
  classicalSetBit(clState.bit);
}

// ============================================================
//  QUANTUM BIT-FLIP CODE STEPPER
// ============================================================
const qbfData = {
  step: 0,
  errorQubit: -1,
  maxSteps: 5,
  steps: [
    {
      title: 'Step 1 — Initial state',
      desc: 'We have our logical qubit |&psi;&#10217; = &alpha;|0&#10217; + &beta;|1&#10217; and two ancilla qubits initialized to |0&#10217;. The full state is (&alpha;|0&#10217; + &beta;|1&#10217;) &otimes; |00&#10217;.',
      qubits: ['|&psi;&#10217;', '|0&#10217;', '|0&#10217;'],
      classes: ['ket', 'ket', 'ket'],
      syndromes: ['—', '—']
    },
    {
      title: 'Step 2 — Encode with CNOTs',
      desc: 'Apply CNOT(1&rarr;2) and CNOT(1&rarr;3). This entangles the qubits: the state becomes &alpha;|000&#10217; + &beta;|111&#10217;. Note: we have NOT copied the state — this is an entangled superposition, not three independent copies.',
      qubits: ['&alpha;|0&#10217;+&beta;|1&#10217;', '&#8226;', '&#8226;'],
      classes: ['ket', 'ket', 'ket'],
      syndromes: ['—', '—'],
      labels: ['&alpha;|000&#10217; + &beta;|111&#10217;']
    },
    null, // error step — filled dynamically
    {
      title: 'Step 4 — Measure syndrome',
      desc: '', // filled dynamically
      syndromes: [], // filled dynamically
    },
    {
      title: 'Step 5 — Correct',
      desc: '', // filled dynamically
    }
  ]
};

function qbfRender() {
  const s = qbfData.step;
  document.getElementById('qbf-step-label').textContent = `Step ${s + 1} / ${qbfData.maxSteps}`;
  document.getElementById('qbf-progress').style.width = ((s + 1) / qbfData.maxSteps * 100) + '%';
  document.getElementById('qbf-prev-btn').disabled = s === 0;
  document.getElementById('qbf-next-btn').disabled = (s === 2 && qbfData.errorQubit === undefined) || s === qbfData.maxSteps - 1;
  updateStateFlow('qbf-flow', s);
  document.getElementById('qbf-s0').classList.remove('syndrome-reveal');
  document.getElementById('qbf-s1').classList.remove('syndrome-reveal');

  const errSel = document.getElementById('qbf-error-sel');
  errSel.classList.toggle('disabled', s !== 2);
  if (s === 2 && qbfData.errorQubit === undefined) errSel.classList.add('active-hint');
  else errSel.classList.remove('active-hint');

  if (s === 0) {
    setQbf(['|&psi;&#10217;', '|0&#10217;', '|0&#10217;'], ['ket','ket','ket'], ['—','—']);
    document.getElementById('qbf-desc').innerHTML = '<strong>Step 1 — Initial state:</strong> We have our logical qubit |&psi;&#10217; = &alpha;|0&#10217; + &beta;|1&#10217; and two ancilla qubits initialized to |0&#10217;.';
  } else if (s === 1) {
    setQbf(['encoded', 'encoded', 'encoded'], ['ket','ket','ket'], ['—','—']);
    document.getElementById('qbf-q0').innerHTML = '&alpha;0+&beta;1';
    document.getElementById('qbf-q1').innerHTML = '&#8226;';
    document.getElementById('qbf-q2').innerHTML = '&#8226;';
    document.getElementById('qbf-desc').innerHTML = '<strong>Step 2 — Encode:</strong> Apply <span class="gate gate-cnot">CNOT</span>(1&rarr;2) and <span class="gate gate-cnot">CNOT</span>(1&rarr;3). State: &alpha;|000&#10217; + &beta;|111&#10217;. This is entanglement, not cloning!';
  } else if (s === 2) {
    const e = qbfData.errorQubit;
    if (e === undefined) {
      setQbf(['&#10003;', '&#10003;', '&#10003;'], ['ket','ket','ket'], ['—','—']);
      document.getElementById('qbf-desc').innerHTML = '<strong>Step 3 — Error channel:</strong> Choose which qubit gets a bit-flip <span class="gate gate-x">X</span> error (or no error).';
    } else if (e === -1) {
      setQbf(['&#10003;', '&#10003;', '&#10003;'], ['ket','ket','ket'], ['—','—']);
      document.getElementById('qbf-desc').innerHTML = '<strong>Step 3 — No error:</strong> The state remains &alpha;|000&#10217; + &beta;|111&#10217;. Press Next to measure the syndrome.';
    } else {
      const cls = ['ket','ket','ket'];
      const vals = ['&#10003;', '&#10003;', '&#10003;'];
      cls[e] = 'error';
      vals[e] = '<span class="gate gate-x">X</span>';
      setQbf(vals, cls, ['—','—']);
      document.getElementById('qbf-desc').innerHTML = `<strong>Step 3 — Error!</strong> A bit-flip <span class="gate gate-x">X</span> hits qubit ${e+1}. The state is now corrupted, but the entanglement structure lets us detect this.`;
    }
  } else if (s === 3) {
    const e = qbfData.errorQubit;
    let s0 = 0, s1 = 0;
    if (e === 0) { s0 = 1; s1 = 0; }
    else if (e === 1) { s0 = 1; s1 = 1; }
    else if (e === 2) { s0 = 0; s1 = 1; }
    const cls = ['ket','ket','ket'];
    const vals = ['&#10003;', '&#10003;', '&#10003;'];
    if (e >= 0) { cls[e] = 'error'; vals[e] = '<span class="gate gate-x">X</span>'; }
    setQbf(vals, cls, [s0.toString(), s1.toString()]);
    const sClasses = [s0 ? 'syndrome' : '', s1 ? 'syndrome' : ''];
    if (sClasses[0]) document.getElementById('qbf-s0').classList.add('syndrome');
    if (sClasses[1]) document.getElementById('qbf-s1').classList.add('syndrome');
    void document.getElementById('qbf-s0').offsetWidth;
    document.getElementById('qbf-s0').classList.add('syndrome-reveal');
    document.getElementById('qbf-s1').classList.add('syndrome-reveal');

    if (e === -1) {
      document.getElementById('qbf-desc').innerHTML = '<strong>Step 4 — Syndrome measurement:</strong> Measure Z&#8321;Z&#8322; = <span class="math">0</span> and Z&#8322;Z&#8323; = <span class="math">0</span>. Syndrome (0,0) &rarr; no error detected. Correct!';
    } else {
      document.getElementById('qbf-desc').innerHTML = `<strong>Step 4 — Syndrome measurement:</strong> Measure Z&#8321;Z&#8322; = <span class="math">${s0}</span> and Z&#8322;Z&#8323; = <span class="math">${s1}</span>. Syndrome (${s0},${s1}) &rarr; error on qubit ${e+1} detected! These measurements reveal the error location without collapsing &alpha; or &beta;.`;
    }
  } else if (s === 4) {
    const e = qbfData.errorQubit;
    setQbf(['&#10003;', '&#10003;', '&#10003;'], ['corrected','corrected','corrected'], ['&#10003;','&#10003;']);
    document.getElementById('qbf-s0').classList.add('corrected');
    document.getElementById('qbf-s1').classList.add('corrected');
    if (e === -1) {
      document.getElementById('qbf-desc').innerHTML = '<strong>Step 5 — No correction needed:</strong> The syndrome was (0,0), so no error occurred. The state &alpha;|000&#10217; + &beta;|111&#10217; is intact.';
    } else {
      document.getElementById('qbf-desc').innerHTML = `<strong>Step 5 — Correction:</strong> Apply <span class="gate gate-x">X</span> to qubit ${e+1}. The state is restored to &alpha;|000&#10217; + &beta;|111&#10217;. The logical qubit is recovered! Decode by reversing the CNOTs to get back &alpha;|0&#10217; + &beta;|1&#10217;.`;
    }
  }
  // Circuit gate highlights
  highlightGates('qbf', s === 1 ? ['cnot1', 'cnot2'] : []);
}

function setQbf(vals, cls, syn) {
  const stateLabel = c => c === 'error' ? 'error' : c === 'corrected' ? 'corrected' : 'normal';
  for (let i = 0; i < 3; i++) {
    const el = document.getElementById('qbf-q' + i);
    el.innerHTML = vals[i];
    el.className = 'qubit-box ' + cls[i];
    el.setAttribute('aria-label', `Qubit ${i+1}: ${el.textContent}, ${stateLabel(cls[i])}`);
  }
  for (let i = 0; i < 2; i++) {
    const el = document.getElementById('qbf-s' + i);
    el.innerHTML = syn[i];
    el.className = 'qubit-box';
    el.setAttribute('aria-label', `Syndrome ${i+1}: ${syn[i]}`);
  }
}

function qbfNext() {
  if (qbfData.step === 2 && qbfData.errorQubit === undefined) return;
  if (qbfData.step < qbfData.maxSteps - 1) { qbfData.step++; animateStep('qbf-desc', qbfRender); }
}
function qbfPrev() {
  if (qbfData.step > 0) {
    if (qbfData.step <= 2) qbfData.errorQubit = undefined;
    qbfData.step--;
    animateStep('qbf-desc', qbfRender);
  }
}
function qbfReset() { qbfData.step = 0; qbfData.errorQubit = undefined; qbfRender(); }
function qbfSelectError(e) {
  qbfData.errorQubit = e;
  document.querySelectorAll('#qbf-error-sel button').forEach(b => { b.classList.remove('active'); b.setAttribute('aria-pressed', 'false'); });
  const id = e === -1 ? 'qbf-en' : 'qbf-e' + e;
  const btn = document.getElementById(id);
  btn.classList.add('active'); btn.setAttribute('aria-pressed', 'true');
  qbfRender();
}

// Init
qbfRender();

// ============================================================
//  SYNDROME DECODER WIDGET
// ============================================================
const sdBits = [0, 1]; // initial state matches HTML

function sdToggle(i) {
  sdBits[i] = 1 - sdBits[i];
  sdRender();
}

function sdRender() {
  for (let i = 0; i < 2; i++) {
    const btn = document.getElementById('sd-s' + i);
    btn.textContent = sdBits[i];
    btn.setAttribute('aria-pressed', sdBits[i] === 1);
    btn.setAttribute('aria-label', `Syndrome bit ${i+1}: ${sdBits[i]}`);
  }
  // Decode: (0,0)=none, (1,0)=q1, (1,1)=q2, (0,1)=q3
  const s0 = sdBits[0], s1 = sdBits[1];
  let target = -1;
  if (s0 === 1 && s1 === 0) target = 0;
  else if (s0 === 1 && s1 === 1) target = 1;
  else if (s0 === 0 && s1 === 1) target = 2;

  for (let i = 0; i < 3; i++) {
    const el = document.getElementById('sd-q' + i);
    el.className = 'qubit-box' + (i === target ? ' sd-highlight' : '');
  }

  const res = document.getElementById('sd-result');
  if (target === -1) {
    res.innerHTML = '<strong>Syndrome (0,0):</strong> No error detected — all qubits agree.';
  } else {
    res.innerHTML = `<strong>Syndrome (${s0},${s1}):</strong> Error on qubit ${target+1} — apply X to qubit ${target+1}.`;
  }
}
sdRender();

// ============================================================
//  HADAMARD DEMO
// ============================================================
let hadBasis = 0; // 0 = |0>, 1 = |1>

function hadReset() {
  document.getElementById('had-result-grid').classList.remove('visible');
  document.getElementById('had-msg').textContent = 'Choose an error to apply and see what happens when you transform back with H.';
  hadRenderStart();
}

function hadRenderStart() {
  const s = hadBasis === 0 ? '|0&#10217;' : '|1&#10217;';
  const h = hadBasis === 0 ? '|+&#10217;' : '|&minus;&#10217;';
  document.getElementById('had-start').innerHTML = s;
  document.getElementById('had-after-h').innerHTML = h;
}

function hadToggleBasis() {
  hadBasis = 1 - hadBasis;
  document.getElementById('had-basis-btn').textContent =
    hadBasis === 0 ? 'Start with |1\u27E9 instead' : 'Start with |0\u27E9 instead';
  hadReset();
}

function hadApply(err) {
  document.getElementById('had-result-grid').classList.add('visible');
  // State after H: |+> or |->
  // If basis=0: state after H is |+>
  // If basis=1: state after H is |->

  const isPlus = hadBasis === 0;
  let afterErr, afterFinalH, msg;

  if (err === 'X') {
    if (isPlus) {
      afterErr = '|+&#10217;';  // X|+> = |+>
      afterFinalH = '|0&#10217;'; // H|+> = |0>
      msg = '<strong>X on |+&#10217; = |+&#10217;</strong> (unchanged!). X acts trivially on |+&#10217;. After the final H: H|+&#10217; = |0&#10217;. The X error had <em>no visible effect</em> in the Hadamard basis — it behaves like the identity. But in the computational basis, the round trip gives the same |0&#10217; we started with.';
    } else {
      afterErr = '&minus;|&minus;&#10217;'; // X|-> = -|->
      afterFinalH = '&minus;|1&#10217;'; // H(-|->) = -|1>
      msg = '<strong>X on |&minus;&#10217; = &minus;|&minus;&#10217;</strong> (a phase flip!). X acts as a <em>phase flip</em> in the Hadamard basis. After the final H: back to &minus;|1&#10217;. So H X H = Z : the X error became a Z error!';
    }
  } else { // Z
    if (isPlus) {
      afterErr = '|&minus;&#10217;'; // Z|+> = |->
      afterFinalH = '|1&#10217;'; // H|-> = |1>
      msg = '<strong>Z on |+&#10217; = |&minus;&#10217;</strong> (a bit-flip in the Hadamard basis!). The phase-flip swapped |+&#10217; and |&minus;&#10217;. After the final H: H|&minus;&#10217; = |1&#10217;. So H Z H = X : the Z error became an X error!';
    } else {
      afterErr = '|+&#10217;'; // Z|-> = -|+> ... actually Z|-> = |+> wait
      // Z|-> = Z(|0>-|1>)/sqrt2 = (|0>+|1>)/sqrt2 = |+> ... hmm
      // Actually: Z|-> = Z(|0>-|1>)/sqrt2 = (Z|0>-Z|1>)/sqrt2 = (|0>-(-|1>))/sqrt2 = (|0>+|1>)/sqrt2 = |+>
      // Hmm wait. Z|0>=|0>, Z|1>=-|1>. So Z(|0>-|1>)/sqrt2 = (|0>+|1>)/sqrt2 = |+>. Yes.
      afterErr = '|+&#10217;';
      afterFinalH = '|0&#10217;'; // H|+> = |0>
      msg = '<strong>Z on |&minus;&#10217; = |+&#10217;</strong> (a bit-flip in the Hadamard basis!). The phase-flip swapped |&minus;&#10217; to |+&#10217;. After H: H|+&#10217; = |0&#10217;. Started with |1&#10217;, got |0&#10217; — the Z error acted like an X error through the conjugation.';
    }
  }

  document.getElementById('had-after-err').innerHTML = afterErr;
  document.getElementById('had-final').innerHTML = afterFinalH;
  document.getElementById('had-msg').innerHTML = msg;
}

hadRenderStart();

// ============================================================
//  PHASE-FLIP CODE STEPPER
// ============================================================
const pfData = { step: 0, errorQubit: undefined, maxSteps: 5 };

function pfRender() {
  const s = pfData.step;
  document.getElementById('pf-step-label').textContent = `Step ${s + 1} / ${pfData.maxSteps}`;
  document.getElementById('pf-progress').style.width = ((s + 1) / pfData.maxSteps * 100) + '%';
  document.getElementById('pf-prev-btn').disabled = s === 0;
  document.getElementById('pf-next-btn').disabled = (s === 2 && pfData.errorQubit === undefined) || s === pfData.maxSteps - 1;
  updateStateFlow('pf-flow', s);
  document.getElementById('pf-s0').classList.remove('syndrome-reveal');
  document.getElementById('pf-s1').classList.remove('syndrome-reveal');

  const errSel = document.getElementById('pf-error-sel');
  errSel.classList.toggle('disabled', s !== 2);
  if (s === 2 && pfData.errorQubit === undefined) errSel.classList.add('active-hint');
  else errSel.classList.remove('active-hint');

  const q = [document.getElementById('pf-q0'), document.getElementById('pf-q1'), document.getElementById('pf-q2')];
  const syn = [document.getElementById('pf-s0'), document.getElementById('pf-s1')];

  if (s === 0) {
    q[0].innerHTML = '|&psi;&#10217;'; q[1].innerHTML = '|0&#10217;'; q[2].innerHTML = '|0&#10217;';
    q.forEach(el => el.className = 'qubit-box ket');
    syn.forEach(el => { el.innerHTML = '—'; el.className = 'qubit-box'; });
    document.getElementById('pf-desc').innerHTML = '<strong>Step 1 — Initial state:</strong> |&psi;&#10217; = &alpha;|0&#10217; + &beta;|1&#10217; with two ancillas |0&#10217;.';
  } else if (s === 1) {
    q[0].innerHTML = '|+/&minus;&#10217;'; q[1].innerHTML = '|+/&minus;&#10217;'; q[2].innerHTML = '|+/&minus;&#10217;';
    q.forEach(el => el.className = 'qubit-box ket');
    syn.forEach(el => { el.innerHTML = '—'; el.className = 'qubit-box'; });
    document.getElementById('pf-desc').innerHTML = '<strong>Step 2 — Encode:</strong> First, CNOT(1&rarr;2) and CNOT(1&rarr;3) give &alpha;|000&#10217; + &beta;|111&#10217;. Then apply <span class="gate gate-h">H</span> to each qubit: &alpha;|+++&#10217; + &beta;|&minus;&minus;&minus;&#10217;. Now the code is in the Hadamard basis!';
  } else if (s === 2) {
    const e = pfData.errorQubit;
    q.forEach((el, i) => { el.innerHTML = '|+/&minus;&#10217;'; el.className = 'qubit-box ket'; });
    syn.forEach(el => { el.innerHTML = '—'; el.className = 'qubit-box'; });
    if (e === undefined) {
      document.getElementById('pf-desc').innerHTML = '<strong>Step 3 — Error channel:</strong> Choose which qubit gets a phase-flip <span class="gate gate-z">Z</span> error.';
    } else if (e === -1) {
      document.getElementById('pf-desc').innerHTML = '<strong>Step 3 — No error.</strong> State is intact. Press Next.';
    } else {
      q[e].className = 'qubit-box error';
      q[e].innerHTML = '<span class="gate gate-z">Z</span>';
      document.getElementById('pf-desc').innerHTML = `<strong>Step 3 — Error!</strong> Phase-flip <span class="gate gate-z">Z</span> on qubit ${e+1}. In the Hadamard basis, Z swaps |+&#10217; and |&minus;&#10217;, so this looks like a bit-flip!`;
    }
  } else if (s === 3) {
    const e = pfData.errorQubit;
    let s0 = 0, s1 = 0;
    if (e === 0) { s0 = 1; s1 = 0; }
    else if (e === 1) { s0 = 1; s1 = 1; }
    else if (e === 2) { s0 = 0; s1 = 1; }
    q.forEach((el, i) => { el.innerHTML = '|+/&minus;&#10217;'; el.className = 'qubit-box ket'; });
    if (e >= 0) { q[e].className = 'qubit-box error'; q[e].innerHTML = '<span class="gate gate-z">Z</span>'; }
    syn[0].innerHTML = s0; syn[1].innerHTML = s1;
    syn[0].className = 'qubit-box' + (s0 ? ' syndrome' : '');
    syn[1].className = 'qubit-box' + (s1 ? ' syndrome' : '');
    void syn[0].offsetWidth;
    syn[0].classList.add('syndrome-reveal');
    syn[1].classList.add('syndrome-reveal');
    if (e === -1) {
      document.getElementById('pf-desc').innerHTML = '<strong>Step 4 — Syndrome:</strong> Measure X&#8321;X&#8322; = <span class="math">0</span>, X&#8322;X&#8323; = <span class="math">0</span>. No error detected.';
    } else {
      document.getElementById('pf-desc').innerHTML = `<strong>Step 4 — Syndrome:</strong> Measure X&#8321;X&#8322; = <span class="math">${s0}</span>, X&#8322;X&#8323; = <span class="math">${s1}</span>. Syndrome (${s0},${s1}) &rarr; phase error on qubit ${e+1}. Note: we measure X-basis parities (not Z), because in the Hadamard basis a Z error looks like a bit-flip.`;
    }
  } else if (s === 4) {
    const e = pfData.errorQubit;
    q.forEach(el => { el.innerHTML = '&#10003;'; el.className = 'qubit-box corrected'; });
    syn.forEach(el => { el.innerHTML = '&#10003;'; el.className = 'qubit-box corrected'; });
    if (e === -1) {
      document.getElementById('pf-desc').innerHTML = '<strong>Step 5 — Done:</strong> No correction needed. State is &alpha;|+++&#10217; + &beta;|&minus;&minus;&minus;&#10217;.';
    } else {
      document.getElementById('pf-desc').innerHTML = `<strong>Step 5 — Correction:</strong> Apply <span class="gate gate-z">Z</span> to qubit ${e+1}. State restored to &alpha;|+++&#10217; + &beta;|&minus;&minus;&minus;&#10217;. To decode: apply H to each qubit, then reverse CNOTs.`;
    }
  }
  // Circuit gate highlights
  highlightGates('pf', s === 1 ? ['cnot1', 'cnot2', 'h123'] : []);
}

function pfNext() {
  if (pfData.step === 2 && pfData.errorQubit === undefined) return;
  if (pfData.step < pfData.maxSteps - 1) { pfData.step++; animateStep('pf-desc', pfRender); }
}
function pfPrev() {
  if (pfData.step > 0) {
    if (pfData.step <= 2) pfData.errorQubit = undefined;
    pfData.step--;
    animateStep('pf-desc', pfRender);
  }
}
function pfReset() { pfData.step = 0; pfData.errorQubit = undefined; pfRender(); }
function pfSelectError(e) {
  pfData.errorQubit = e;
  document.querySelectorAll('#pf-error-sel button').forEach(b => { b.classList.remove('active'); b.setAttribute('aria-pressed', 'false'); });
  const id = e === -1 ? 'pf-en' : 'pf-e' + e;
  const btn = document.getElementById(id);
  btn.classList.add('active'); btn.setAttribute('aria-pressed', 'true');
  pfRender();
}
pfRender();

// ============================================================
//  SHOR'S 9-QUBIT CODE STEPPER
// ============================================================
const shorData = {
  step: 0,
  maxSteps: 7,
  errorType: 'X',
  errorQubit: undefined,
};

function shorErrTab(type) {
  shorData.errorType = type;
  shorData.errorQubit = undefined;
  document.querySelectorAll('#shor-err-tabs .tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('#shor-err-tabs .tab-btn').forEach(b => {
    if (b.textContent.includes(type === 'X' ? 'Bit' : type === 'Z' ? 'Phase' : 'Both')) b.classList.add('active');
  });
  const grid = document.getElementById('shor-error-sel');
  grid.classList.add('tab-fading');
  setTimeout(() => {
    shorBuildErrorSel();
    grid.classList.remove('tab-fading');
  }, 200);
  if (shorData.step === 3) shorRender();
}

function shorBuildErrorSel() {
  const sel = document.getElementById('shor-error-sel');
  const t = shorData.errorType;
  const label = t === 'X' ? 'X' : t === 'Z' ? 'Z' : 'Y';
  const blocks = ['A', 'B', 'C'];
  let html = '';
  for (let b = 0; b < 3; b++) {
    html += `<span class="block-label">Block ${blocks[b]}</span>`;
    for (let j = 0; j < 3; j++) {
      const i = b * 3 + j;
      html += `<button onclick="shorSelectError(${i})" id="shor-e${i}" aria-pressed="false">${label} q${i+1}</button>`;
    }
  }
  html += `<button class="no-error-btn" onclick="shorSelectError(-1)" id="shor-en" aria-pressed="false">No error</button>`;
  sel.innerHTML = html;
}
shorBuildErrorSel();

function shorSelectError(e) {
  shorData.errorQubit = e;
  document.querySelectorAll('#shor-error-sel button').forEach(b => { b.classList.remove('active'); b.setAttribute('aria-pressed', 'false'); });
  const id = e === -1 ? 'shor-en' : 'shor-e' + e;
  const btn = document.getElementById(id);
  btn.classList.add('active'); btn.setAttribute('aria-pressed', 'true');
  shorRender();
}

function shorRender() {
  const s = shorData.step;
  document.getElementById('shor-step-label').textContent = `Step ${s + 1} / ${shorData.maxSteps}`;
  document.getElementById('shor-progress').style.width = ((s + 1) / shorData.maxSteps * 100) + '%';
  document.getElementById('shor-prev-btn').disabled = s === 0;
  document.getElementById('shor-next-btn').disabled = (s === 3 && shorData.errorQubit === undefined) || s === shorData.maxSteps - 1;
  updateStateFlow('shor-flow', s);
  document.getElementById('shor-bfs').classList.remove('syndrome-reveal');
  document.getElementById('shor-pfs').classList.remove('syndrome-reveal');

  const errSel = document.getElementById('shor-error-sel');
  errSel.classList.toggle('disabled', s !== 3);
  if (s === 3 && shorData.errorQubit === undefined) errSel.classList.add('active-hint');
  else errSel.classList.remove('active-hint');

  const qEls = [];
  for (let i = 0; i < 9; i++) qEls.push(document.getElementById('sq' + i));
  const bfs = document.getElementById('shor-bfs');
  const pfs = document.getElementById('shor-pfs');

  // Reset all
  qEls.forEach(el => { el.className = 'qubit-box ket'; });
  bfs.innerHTML = '—'; bfs.className = 'qubit-box';
  pfs.innerHTML = '—'; pfs.className = 'qubit-box';

  if (s === 0) {
    qEls[0].innerHTML = '|&psi;&#10217;';
    for (let i = 1; i < 9; i++) qEls[i].innerHTML = '|0&#10217;';
    document.getElementById('shor-desc').innerHTML = '<strong>Step 1 — Initial state:</strong> Our logical qubit |&psi;&#10217; = &alpha;|0&#10217; + &beta;|1&#10217; sits in qubit 1. Qubits 2-9 are initialized to |0&#10217;.';
  } else if (s === 1) {
    qEls.forEach(el => el.innerHTML = '&#8226;');
    document.getElementById('shor-desc').innerHTML = '<strong>Step 2 — Phase-flip encoding (outer code):</strong> Apply CNOT(q1&rarr;q4) and CNOT(q1&rarr;q7). Now the state is &alpha;|000&#10217;<sub>blocks</sub> + &beta;|111&#10217;<sub>blocks</sub>, where each "0" and "1" represents a block. Then apply <span class="gate gate-h">H</span> to q1, q4, q7 to switch to the Hadamard basis.';
  } else if (s === 2) {
    for (let i = 0; i < 9; i++) {
      const blockLabels = ['a','a','a','b','b','b','c','c','c'];
      qEls[i].innerHTML = blockLabels[i];
    }
    document.getElementById('shor-desc').innerHTML = '<strong>Step 3 — Bit-flip encoding (inner code):</strong> Within each block, apply CNOTs to create 3-qubit repetition codes. Block A: CNOT(q1&rarr;q2), CNOT(q1&rarr;q3). Same for blocks B and C. The full encoded state is now:<br><span class="math" style="font-size:0.8rem">&alpha;(|000&#10217;+|111&#10217;)(|000&#10217;+|111&#10217;)(|000&#10217;+|111&#10217;) + &beta;(|000&#10217;&minus;|111&#10217;)(|000&#10217;&minus;|111&#10217;)(|000&#10217;&minus;|111&#10217;)</span> / 2&radic;2';
  } else if (s === 3) {
    // Error step
    for (let i = 0; i < 9; i++) qEls[i].innerHTML = '&#10003;';
    const e = shorData.errorQubit;
    if (e === undefined) {
      document.getElementById('shor-desc').innerHTML = '<strong>Step 4 — Error channel:</strong> Choose an error type and which qubit it hits. You can apply a bit-flip (X), phase-flip (Z), or both (Y).';
    } else if (e === -1) {
      document.getElementById('shor-desc').innerHTML = '<strong>Step 4 — No error applied.</strong> The encoded state is pristine. Press Next.';
    } else {
      const t = shorData.errorType;
      qEls[e].className = 'qubit-box error';
      qEls[e].innerHTML = `<span class="gate gate-${t.toLowerCase()}">${t}</span>`;
      const block = ['A','A','A','B','B','B','C','C','C'][e];
      const posInBlock = e % 3 + 1;
      document.getElementById('shor-desc').innerHTML = `<strong>Step 4 — Error!</strong> ${t === 'X' ? 'Bit-flip' : t === 'Z' ? 'Phase-flip' : 'Bit+phase-flip'} <span class="gate gate-${t.toLowerCase()}">${t}</span> on qubit ${e+1} (Block ${block}, position ${posInBlock}).`;
    }
  } else if (s === 4) {
    // Bit-flip syndrome
    const e = shorData.errorQubit;
    const t = shorData.errorType;
    for (let i = 0; i < 9; i++) qEls[i].innerHTML = '&#10003;';

    let bfSynStr = 'All 0';
    if (e >= 0 && (t === 'X' || t === 'Y')) {
      const block = Math.floor(e / 3);
      const pos = e % 3;
      const blockName = ['A','B','C'][block];
      let s0 = 0, s1 = 0;
      if (pos === 0) { s0 = 1; s1 = 0; }
      else if (pos === 1) { s0 = 1; s1 = 1; }
      else { s0 = 0; s1 = 1; }
      bfSynStr = `Block ${blockName}: (${s0},${s1})`;
      qEls[e].className = 'qubit-box error';
      qEls[e].innerHTML = `<span class="gate gate-${t.toLowerCase()}">${t}</span>`;
      document.getElementById('shor-desc').innerHTML = `<strong>Step 5 — Bit-flip syndrome:</strong> Measure Z-parity within each block. Block ${blockName} shows syndrome (${s0},${s1}) &rarr; bit-flip detected on position ${pos+1}. Apply X to qubit ${e+1} to correct the bit-flip component.`;
    } else {
      if (e >= 0) {
        qEls[e].className = 'qubit-box error';
        qEls[e].innerHTML = `<span class="gate gate-z">Z</span>`;
      }
      document.getElementById('shor-desc').innerHTML = '<strong>Step 5 — Bit-flip syndrome:</strong> Measure Z-parity within each block. All syndromes are (0,0) &mdash; no bit-flip component detected.' + (e >= 0 ? ' The Z error is invisible to these checks!' : '');
    }
    bfs.innerHTML = bfSynStr;
    bfs.className = 'qubit-box' + (bfSynStr !== 'All 0' ? ' syndrome' : '');
    void bfs.offsetWidth;
    bfs.classList.add('syndrome-reveal');
  } else if (s === 5) {
    // Phase-flip syndrome
    const e = shorData.errorQubit;
    const t = shorData.errorType;
    for (let i = 0; i < 9; i++) qEls[i].innerHTML = '&#10003;';

    bfs.innerHTML = (e >= 0 && (t === 'X' || t === 'Y')) ? 'Corrected' : 'All 0';
    bfs.className = 'qubit-box' + ((e >= 0 && (t === 'X' || t === 'Y')) ? ' corrected' : '');

    let pfSynStr = 'All 0';
    if (e >= 0 && (t === 'Z' || t === 'Y')) {
      const block = Math.floor(e / 3);
      const blockName = ['A','B','C'][block];
      let p0 = 0, p1 = 0;
      if (block === 0) { p0 = 1; p1 = 0; }
      else if (block === 1) { p0 = 1; p1 = 1; }
      else { p0 = 0; p1 = 1; }
      pfSynStr = `(${p0},${p1}) → Block ${blockName}`;
      document.getElementById('shor-desc').innerHTML = `<strong>Step 6 — Phase-flip syndrome:</strong> ${t === 'Y' ? 'After correcting the bit-flip, the' : 'The'} remaining phase error is detected by measuring X&#8321;X&#8322;X&#8323;X&#8324;X&#8325;X&#8326; and X&#8324;X&#8325;X&#8326;X&#8327;X&#8328;X&#8329;. Syndrome (${p0},${p1}) &rarr; phase-flip in Block ${blockName}. Apply Z to any qubit in that block.`;
    } else {
      document.getElementById('shor-desc').innerHTML = '<strong>Step 6 — Phase-flip syndrome:</strong> Measure cross-block X-parities. All syndromes are (0,0) &mdash; no phase-flip detected.' + (e >= 0 ? ' The X error was already fully corrected in the previous step.' : '');
    }
    pfs.innerHTML = pfSynStr;
    pfs.className = 'qubit-box' + (pfSynStr !== 'All 0' ? ' syndrome' : '');
    void pfs.offsetWidth;
    pfs.classList.add('syndrome-reveal');
  } else if (s === 6) {
    // Corrected
    for (let i = 0; i < 9; i++) {
      qEls[i].innerHTML = '&#10003;';
      qEls[i].className = 'qubit-box corrected';
    }
    bfs.innerHTML = '&#10003;'; bfs.className = 'qubit-box corrected';
    pfs.innerHTML = '&#10003;'; pfs.className = 'qubit-box corrected';
    const e = shorData.errorQubit;
    const t = shorData.errorType;
    if (e === -1 || e === undefined) {
      document.getElementById('shor-desc').innerHTML = '<strong>Step 7 — State recovered!</strong> No errors occurred. The logical qubit |&psi;&#10217;<sub>L</sub> = &alpha;|0&#10217;<sub>L</sub> + &beta;|1&#10217;<sub>L</sub> is safe.';
    } else {
      document.getElementById('shor-desc').innerHTML = `<strong>Step 7 — State recovered!</strong> The ${t} error on qubit ${e+1} has been fully corrected. The logical qubit is restored: |&psi;&#10217;<sub>L</sub> = &alpha;|0&#10217;<sub>L</sub> + &beta;|1&#10217;<sub>L</sub>. Shor's code successfully corrected a${t === 'Y' ? ' combined bit+phase' : t === 'X' ? ' bit-flip' : ' phase-flip'} error!`;
    }
  }
}

// Post-render: add ARIA labels to all Shor qubit boxes
function shorAriaUpdate() {
  for (let i = 0; i < 9; i++) {
    const el = document.getElementById('sq' + i);
    const state = el.classList.contains('error') ? 'error' : el.classList.contains('corrected') ? 'corrected' : 'normal';
    el.setAttribute('aria-label', `Qubit ${i+1}: ${el.textContent}, ${state}`);
  }
  ['shor-bfs','shor-pfs'].forEach(id => {
    const el = document.getElementById(id);
    el.setAttribute('aria-label', `Syndrome: ${el.textContent}`);
  });
}

function shorNext() {
  if (shorData.step === 3 && shorData.errorQubit === undefined) return;
  if (shorData.step < shorData.maxSteps - 1) { shorData.step++; animateStep('shor-desc', () => { shorRender(); shorAriaUpdate(); }); }
}
function shorPrev() {
  if (shorData.step > 0) {
    if (shorData.step <= 3) shorData.errorQubit = undefined;
    shorData.step--;
    animateStep('shor-desc', shorRender);
  }
}
function shorReset() { shorData.step = 0; shorData.errorQubit = undefined; shorRender(); }
shorRender();

// ============================================================
//  NAV HIGHLIGHT
// ============================================================
const sections = document.querySelectorAll('section[id]');
const navLinks = document.querySelectorAll('nav a');

let scrollTicking = false;
window.addEventListener('scroll', () => {
  if (scrollTicking) return;
  scrollTicking = true;
  requestAnimationFrame(() => {
    let current = '';
    sections.forEach(sec => {
      if (window.scrollY >= sec.offsetTop - 100) current = sec.id;
    });
    navLinks.forEach(a => {
      a.classList.toggle('active', a.getAttribute('href') === '#' + current);
    });
    scrollTicking = false;
  });
});

// Initialize classical demo
classicalSetBit(0);

// ============================================================
//  LIMITATIONS: MULTI-ERROR DEMO
// ============================================================
const limErrors = [false, false, false];

function limToggle(i) {
  limErrors[i] = !limErrors[i];
  limRender();
}

function limRender() {
  const count = limErrors.filter(Boolean).length;
  // Update qubit boxes
  for (let i = 0; i < 3; i++) {
    const el = document.getElementById('lim-q' + i);
    el.className = 'qubit-box' + (limErrors[i] ? ' error' : '');
    el.textContent = limErrors[i] ? 'X|ψ⟩' : '|ψ⟩';
    el.setAttribute('aria-pressed', limErrors[i]);
    el.setAttribute('aria-label', `Qubit ${i+1}: ${limErrors[i] ? 'error' : 'no error'}`);
  }
  // Compute syndrome: s0 = q0 XOR q1, s1 = q1 XOR q2
  const s0 = limErrors[0] !== limErrors[1] ? 1 : 0;
  const s1 = limErrors[1] !== limErrors[2] ? 1 : 0;
  document.getElementById('lim-s0').textContent = s0;
  document.getElementById('lim-s1').textContent = s1;

  // Decoder lookup (assumes single error)
  let decoded, decoderTarget;
  if (s0 === 0 && s1 === 0) { decoded = null; decoderTarget = -1; }
  else if (s0 === 1 && s1 === 0) { decoded = 0; decoderTarget = 0; }
  else if (s0 === 1 && s1 === 1) { decoded = 1; decoderTarget = 1; }
  else { decoded = 2; decoderTarget = 2; }

  const res = document.getElementById('lim-result');
  if (count === 0) {
    res.className = 'callout success';
    res.innerHTML = '<p><strong>No errors.</strong> Syndrome (0,0) — the decoder sees no problem.</p>';
  } else if (count === 1) {
    const q = limErrors.indexOf(true);
    res.className = 'callout success';
    res.innerHTML = `<p><strong>1 error on qubit ${q+1}.</strong> Syndrome (${s0},${s1}) correctly identifies qubit ${q+1}. The decoder applies X to qubit ${q+1} — correction succeeds!</p>`;
  } else if (count === 2) {
    const errQubits = limErrors.map((e,i) => e ? i+1 : null).filter(Boolean);
    if (s0 === 0 && s1 === 0) {
      res.className = 'callout warn';
      res.innerHTML = `<p><strong>2 errors on qubits ${errQubits.join(' & ')}.</strong> Syndrome (0,0) — the decoder sees <em>no error</em>! The two errors cancel each other's parity, making them invisible. <strong>Correction fails silently.</strong></p>`;
    } else {
      res.className = 'callout warn';
      res.innerHTML = `<p><strong>2 errors on qubits ${errQubits.join(' & ')}.</strong> Syndrome (${s0},${s1}) points to qubit ${decoderTarget+1} — but that qubit ${limErrors[decoderTarget] ? 'already has an error' : 'is fine'}! The decoder applies X to the <em>wrong</em> qubit, making things worse (now 3 errors). <strong>Correction fails.</strong></p>`;
    }
  } else {
    res.className = 'callout warn';
    res.innerHTML = `<p><strong>3 errors (all qubits).</strong> Syndrome (0,0) — all parities cancel! The decoder sees no error, but every qubit is wrong. <strong>The code is completely defeated.</strong></p>`;
  }
}

// ============================================================
//  SECTION ENTRY ANIMATIONS (IntersectionObserver)
// ============================================================
const sectionObserver = new IntersectionObserver((entries, obs) => {
  entries.forEach(e => {
    if (e.isIntersecting) {
      const el = e.target;
      el.classList.add('visible');
      obs.unobserve(el);
      // Clean up classes after animation (with fallback timeout)
      const cleanup = () => el.classList.remove('animate-in', 'visible');
      el.addEventListener('animationend', cleanup, { once: true });
      setTimeout(cleanup, 800);
    }
  });
}, { threshold: 0.05 });
document.querySelectorAll('section').forEach(s => {
  const rect = s.getBoundingClientRect();
  if (rect.top > window.innerHeight) {
    s.classList.add('animate-in');
    sectionObserver.observe(s);
  }
});

// ============================================================
//  STEP TRANSITION ANIMATION HELPER
// ============================================================
function animateStep(descId, updateFn) {
  const el = document.getElementById(descId);
  el.classList.add('fading');
  setTimeout(() => {
    updateFn();
    el.classList.remove('fading');
  }, 250);
}
</script>


<footer style="text-align:center;padding:2rem 1.5rem;border-top:1px solid var(--border,#2a3550);color:var(--text-dim,#8892a8);font-family:'Inter',sans-serif;font-size:0.82rem;margin-top:3rem;">
  <p style="margin:0 0 0.3rem;">This is a <span style="color:var(--orange,#fb923c);font-weight:500;">beta version</span></p>
  <p style="margin:0;">By <a href="https://granha.github.io" target="_blank" rel="noopener" style="color:var(--accent,#6366f1);text-decoration:none;">Fernando Granha Jeronimo</a></p>
</footer>

<!-- Particle Background -->
<script>
(function initParticles() {
  const canvas = document.getElementById('particleBg');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  let particles = [];
  let animId;
  let paused = false;
  const PARTICLE_COUNT = 45;
  const CONNECT_DIST = 120;
  const colors = [
    'rgba(99, 102, 241, 0.4)',
    'rgba(34, 211, 238, 0.35)',
    'rgba(244, 114, 182, 0.3)',
  ];

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function createParticles() {
    particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.4,
        vy: (Math.random() - 0.5) * 0.4,
        r: Math.random() * 2 + 1,
        color: colors[Math.floor(Math.random() * colors.length)],
      });
    }
  }

  function draw() {
    if (paused) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < CONNECT_DIST) {
          const alpha = (1 - dist / CONNECT_DIST) * 0.15;
          ctx.strokeStyle = `rgba(99, 102, 241, ${alpha})`;
          ctx.lineWidth = 0.5;
          ctx.beginPath();
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.stroke();
        }
      }
    }

    for (const p of particles) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.fill();

      p.x += p.vx;
      p.y += p.vy;
      if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
      if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
    }

    animId = requestAnimationFrame(draw);
  }

  window.addEventListener('resize', () => { resize(); createParticles(); });
  document.addEventListener('visibilitychange', () => {
    paused = document.hidden;
    if (!paused) draw();
  });

  resize();
  createParticles();
  draw();
})();
</script>
</body>
</html>
